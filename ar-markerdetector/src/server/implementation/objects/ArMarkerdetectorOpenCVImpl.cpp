/**
Licensing and distribution

ArModule is licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.

ALVAR 2.0.0 - A Library for Virtual and Augmented Reality Copyright 2007-2012 VTT Technical Research Centre of Finland Licensed under the GNU Lesser General Public License

Irrlicht Engine, the zlib and libpng. The Irrlicht Engine is based in part on the work of the Independent JPEG Group The module utilizes IJG code when the Irrlicht engine is compiled with support for JPEG images.
*/

/** @author Markus Ylikerälä */

/* Autogenerated with kurento-module-creator */
#include "ArMarkerdetectorOpenCVImpl.hpp"
#include <KurentoException.hpp>
#include "ArMarkerPose.hpp"

#define SHOWRESO 0
#define TWISTRESO 0
#define SKIPFRAMES 1

namespace kurento
{
namespace module
{
namespace armarkerdetector
{

ArMarkerdetectorOpenCVImpl::ArMarkerdetectorOpenCVImpl ()
{
}

/*
 * This function will be called with each new frame. mat variable
 * contains the current frame. You should insert your image processing code
 * here. Any changes in mat, will be sent through the Media Pipeline.
 */
void ArMarkerdetectorOpenCVImpl::process (cv::Mat &orgMat)
{
  unsigned long timeStamp = 0;
  ar.getTimeStamp(&timeStamp);
  //std::cout << std::endl <<"***SMART KMS (WITHOUT ARFILTER)\t" << ar.getElapsedTime()<< std::endl;

  ar.SMART_TIMESTAMP("KMS (WITHOUT ARFILTER)", ar.getElapsedTime());

  //std::cout << std::endl <<"***SMART TIME\t" << timeStamp << std::endl;
  ar.start();

#if SHOWRESO
  std::cout << std::endl <<"PROCESS...:"
	    << " cols:" << orgMat.cols
	    << " rows:" << orgMat.rows 
	    << std::endl<<std::flush;
#endif

  int width = orgMat.cols;
  int height = orgMat.rows;
  bool twisted = false;
  cv::Mat mat;

#if TWISTRESO
  //if(width != 320 || height != 240){
  //  cv::resize(orgMat, mat, cv::Size(320, 240));
  if(width != 640 || height != 480){
    cv::resize(orgMat, mat, cv::Size(640, 480));
    twisted = true;
#if SHOWRESO
    std::cout<<"IMG RESIZED o_O"	      
	     << " cols:" << mat.cols
	     << " rows:" << mat.rows 
	     << std::endl<<std::flush;
#endif
  }
#endif


  try{
  ar.resetFilterTime();
  ar.proactivate(twisted ? mat : orgMat);

#if SKIPFRAMES
  ar.skipFrames = !ar.skipFrames;
  if(ar.skipFrames){
    ar.shadow.copyTo(orgMat);
    //std::cout << "AR COPY" << std::endl;
    return;
  }
  //std::cout << "AR NOT COPY" << std::endl;  
#endif

  //std::cout << std::endl <<"***SMART PROACTIVE\t" << ar.getFilterTime()<< std::endl;

  //SMART_TIMESTAMP("PROACTIVE", ar.getFilterTime());

  ar.resetFilterTime();
  ar.detect(twisted ? mat : orgMat);
  //std::cout << std::endl <<"***SMART ALLDETECTED\t" << ar.getFilterTime()<< std::endl;
  ar.SMART_TIMESTAMP("ALLDETECTED", ar.getFilterTime());

#if 0
#if SHOWRESO
  std::cout<<"DETECTED:" << ar.detectedMarkerData.size()   
	   << std::endl<<std::flush;
#endif
#endif

  ar.resetFilterTime();
  ar.augment(twisted ? mat : orgMat);  
  //std::cout << std::endl <<"***SMART ALL AUGMENTED\t" << ar.getFilterTime()<< std::endl;
  ar.SMART_TIMESTAMP("ALL AUGMENTED", ar.getFilterTime());

  ar.resetFilterTime();
  ar.generateEvents(getSharedFromThis(), signalMarkerPose, signalMarkerCount, signalTick, twisted ? mat : orgMat);
  //std::cout << std::endl <<"***SMART ALL EVENTS\t" << ar.getFilterTime()<< std::endl;

#if SKIPFRAMES
  orgMat.copyTo(ar.shadow);
  //std::cout << "AR FRESH" << std::endl;
#endif
  }
catch (const std::exception& ex) {
  std::cout << std::endl <<"BIZARRE EXP :" << ex.what()
	    << std::endl<<std::flush;    
} catch (const std::string& ex) {
    std::cout << std::endl <<"BIZARRE EXPSTR :" << ex
	    << std::endl<<std::flush;    
} 
  catch(...){
  std::cout << std::endl <<"BIZARRE ALL:"
	    << std::endl<<std::flush;    
  }

  //ar.detectedMarkerData.clear();
  //std::cout << std::endl <<"EVENTS:"
//	    << " cols:" << signalMarkerPose.size()
//	    << " rows:" << signalMarkerCount.size()
//	    << std::endl<<std::flush;

#if TWISTRESO
    //if(width != 320 || height != 240){
    //  cv::resize(mat, orgMat, cv::Size(width, height));
    if(width != 640 || height != 480){
      cv::resize(mat, orgMat, cv::Size(width, height));
#if 0
      std::cout<<"IMG REVERTED o_O "  
	       << " cols:" << mat.cols
	       << " rows:" << mat.rows 
	       << std::endl<<std::flush;

      if(ar.sequenceNum % 25 == 0){
	std::string str = "/tmp/nubox_" + std::to_string (ar.sequenceNum) + ".png";
	std::cout<<"timeout for" << str << std::endl;
	ar.writeImage(str.c_str(), orgMat);
      }
#endif
    }
#endif
    //std::cout << std::endl <<"***SMART ARFILTER (ONLY)\t"<< ar.getElapsedTime()<< std::endl;
  ar.SMART_TIMESTAMP("ARFILTER (ONLY)", ar.getElapsedTime());
  ar.start();
}
  
  void ArMarkerdetectorOpenCVImpl::setPose (int id, int type, float value){
    ar.setPose (id, type, value);
  }

  void ArMarkerdetectorOpenCVImpl::enableAugmentation (bool enable)
  {
    ar.enableAugmentation(enable);
  }
  
  void ArMarkerdetectorOpenCVImpl::enableMarkerCountEvents (bool enable)
  {
    ar.enableMarkerCountEvents(enable);
  }

  void ArMarkerdetectorOpenCVImpl::enableTickEvents (bool enable){
    ar.enableTickEvents(enable);
  }

void ArMarkerdetectorOpenCVImpl::setArThing (const std::vector<std::shared_ptr<ArThing>> &setArThing)
{
  ar.setArThing(setArThing);
}

  void ArMarkerdetectorOpenCVImpl::setMarkerPoseFrequency (bool enable, float frequency){
    ar.setMarkerPoseFrequency(enable, frequency);
  }

  void ArMarkerdetectorOpenCVImpl::setMarkerPoseFrameFrequency (bool enable, int frequency){
    ar.setMarkerPoseFrameFrequency(enable, frequency);
  }

} /* armarkerdetector */
} /* module */
} /* kurento */
