<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>SampleTrack.cpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>SampleTrack.cpp</h1><p>This is an example that shows how to perform tracking of the optical flow using <em>TrackerPsa</em>, <em>TrackerPsaRot</em>, <em>TrackerFeatures</em> or <em>TrackerStat</em>.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &quot;CvTestbed.h&quot;</span>
<span class="preprocessor">#include &quot;<a class="code" href="_camera_8h.html" title="This file implements a camera used for projecting points and computing homographies...">Camera.h</a>&quot;</span>
<span class="preprocessor">#include &quot;<a class="code" href="_tracker_psa_8h.html" title="This file implements a PSA tracker.">TrackerPsa.h</a>&quot;</span>
<span class="preprocessor">#include &quot;<a class="code" href="_tracker_stat_8h.html" title="This file implements a statistical tracker.">TrackerStat.h</a>&quot;</span>
<span class="preprocessor">#include &quot;<a class="code" href="_tracker_features_8h.html" title="This file implements a feature tracker.">TrackerFeatures.h</a>&quot;</span>
<span class="preprocessor">#include &quot;Shared.h&quot;</span>
<span class="keyword">using namespace </span>alvar;
<span class="keyword">using namespace </span>std;

<span class="keywordtype">int</span> tracker = 0;
<span class="keywordtype">bool</span> reset = <span class="keyword">true</span>;
CvFont font;
std::stringstream calibrationFilename;

<span class="keywordtype">void</span> track_none(IplImage *image, IplImage *img_gray) {
}

<span class="keywordtype">void</span> track_psa(IplImage *image, IplImage *img_gray) {
    <span class="keyword">static</span> <a name="_a0"></a><a class="code" href="classalvar_1_1_tracker_psa.html" title="TrackerPsa implements a very simple PSA tracker">TrackerPsa</a> tracker_psa;
    <span class="keyword">static</span> <span class="keywordtype">double</span> x, y;
    <span class="keywordflow">if</span> (reset) {
        reset = <span class="keyword">false</span>;
        x = img_gray-&gt;width / 2;
        y = img_gray-&gt;height / 2;
        tracker_psa.<a name="a1"></a><a class="code" href="classalvar_1_1_tracker_psa.html#a3fb64376f8b3f6a7babb041c71c2b585" title="Track using PSA.">Track</a>(img_gray); <span class="comment">// To reset tracker call it twice</span>
    }
    tracker_psa.<a class="code" href="classalvar_1_1_tracker_psa.html#a3fb64376f8b3f6a7babb041c71c2b585" title="Track using PSA.">Track</a>(img_gray);
    tracker_psa.<a name="a2"></a>Compensate(&amp;x, &amp;y);
    cvCircle(image, cvPoint(<span class="keywordtype">int</span>(x), <span class="keywordtype">int</span>(y)), 10, CV_RGB(255,0,0));
}

<span class="keywordtype">void</span> track_psa_rot(IplImage *image, IplImage *img_gray) {
    <span class="keyword">static</span> <a name="_a3"></a><a class="code" href="classalvar_1_1_tracker_psa_rot.html" title="TrackerPsaRot implements a slightly extended version of a TrackerPsa which can also...">TrackerPsaRot</a> tracker_psa_rot;
    <span class="keyword">static</span> <span class="keywordtype">double</span> x, y, r;
    <span class="keywordflow">if</span> (reset) {
        reset = <span class="keyword">false</span>;
        x = img_gray-&gt;width / 2;
        y = img_gray-&gt;height / 2;
        r = 0;
        tracker_psa_rot.<a name="a4"></a><a class="code" href="classalvar_1_1_tracker_psa_rot.html#a3fb64376f8b3f6a7babb041c71c2b585" title="Track using PSA with rotation.">Track</a>(img_gray); <span class="comment">// To reset tracker call it twice</span>
    }
    tracker_psa_rot.<a class="code" href="classalvar_1_1_tracker_psa_rot.html#a3fb64376f8b3f6a7babb041c71c2b585" title="Track using PSA with rotation.">Track</a>(img_gray);
    tracker_psa_rot.<a name="a5"></a>Compensate(&amp;x, &amp;y);
    r += tracker_psa_rot.<a name="a6"></a><a class="code" href="classalvar_1_1_tracker_psa_rot.html#a179b71b56cd13f60f9e5c36f80a84c79" title="Track result rotation in degrees">rotd</a>;
    cvCircle(image, cvPoint(<span class="keywordtype">int</span>(x), <span class="keywordtype">int</span>(y)), 15, CV_RGB(255,0,0));
    <span class="keywordtype">double</span> r_rad = r*3.1415926535/180;
    cvLine(image, cvPoint(<span class="keywordtype">int</span>(x), <span class="keywordtype">int</span>(y)), cvPoint(<span class="keywordtype">int</span>(x-sin(r_rad)*15), <span class="keywordtype">int</span>(y+cos(r_rad)*15)), CV_RGB(255,0,0));
}

<span class="keywordtype">void</span> track_stat(IplImage *image, IplImage *img_gray) {
    <span class="keyword">static</span> <a name="_a7"></a><a class="code" href="classalvar_1_1_tracker_stat.html" title="TrackerStat deduces the optical flow based on tracked features using Seppo Valli&amp;#39;s...">TrackerStat</a> tracker_stat;
    <span class="keyword">static</span> <span class="keywordtype">double</span> x, y;
    <span class="keywordflow">if</span> (reset) {
        reset = <span class="keyword">false</span>;
        x = img_gray-&gt;width / 2;
        y = img_gray-&gt;height / 2;
        tracker_stat.<a name="a8"></a><a class="code" href="classalvar_1_1_tracker_stat.html#a3fb64376f8b3f6a7babb041c71c2b585" title="Translation tracker (the simplest possible).">Track</a>(img_gray); <span class="comment">// To reset tracker call it twice</span>
    }
    tracker_stat.<a class="code" href="classalvar_1_1_tracker_stat.html#a3fb64376f8b3f6a7babb041c71c2b585" title="Translation tracker (the simplest possible).">Track</a>(img_gray);
    tracker_stat.<a name="a9"></a>Compensate(&amp;x, &amp;y);
    cvCircle(image, cvPoint(<span class="keywordtype">int</span>(x), <span class="keywordtype">int</span>(y)), 10, CV_RGB(0,255,0));
}

<span class="keywordtype">void</span> track_stat_rot(IplImage *image, IplImage *img_gray) {
    <span class="keyword">static</span> <a name="_a10"></a><a class="code" href="classalvar_1_1_tracker_stat_rot.html" title="TrackerStatRot implements a slightly extended version of TrackerStat which can also...">TrackerStatRot</a> tracker_stat_rot;
    <span class="keyword">static</span> <span class="keywordtype">double</span> x, y, r;
    <span class="keywordflow">if</span> (reset) {
        reset = <span class="keyword">false</span>;
        x = img_gray-&gt;width / 2;
        y = img_gray-&gt;height / 2;
        r = 0;
        tracker_stat_rot.<a name="a11"></a><a class="code" href="classalvar_1_1_tracker_stat_rot.html#a3fb64376f8b3f6a7babb041c71c2b585" title="Translation + rotation tracker.">Track</a>(img_gray); <span class="comment">// To reset tracker call it twice</span>
    }
    tracker_stat_rot.<a class="code" href="classalvar_1_1_tracker_stat_rot.html#a3fb64376f8b3f6a7babb041c71c2b585" title="Translation + rotation tracker.">Track</a>(img_gray);
    tracker_stat_rot.<a name="a12"></a>Compensate(&amp;x, &amp;y);
    r += tracker_stat_rot.<a name="a13"></a><a class="code" href="classalvar_1_1_tracker_stat_rot.html#a179b71b56cd13f60f9e5c36f80a84c79" title="Track result rotation in degrees">rotd</a>;
    cvCircle(image, cvPoint(<span class="keywordtype">int</span>(x), <span class="keywordtype">int</span>(y)), 15, CV_RGB(0,255,0));
    <span class="keywordtype">double</span> r_rad = r*3.1415926535/180;
    cvLine(image, cvPoint(<span class="keywordtype">int</span>(x), <span class="keywordtype">int</span>(y)), cvPoint(<span class="keywordtype">int</span>(x-sin(r_rad)*15), <span class="keywordtype">int</span>(y+cos(r_rad)*15)), CV_RGB(0,255,0));
}

<span class="keywordtype">void</span> track_features(IplImage *image, IplImage *img_gray) {
    <span class="keyword">static</span> <a name="_a14"></a><a class="code" href="classalvar_1_1_tracker_features.html" title="TrackerFeatures tracks features using OpenCV&amp;#39;s cvGoodFeaturesToTrack and cvCalcOpticalFlowPyrLK...">TrackerFeatures</a> tracker_features(200, 190, 0.01, 0, 4, 6);
    <span class="keywordflow">if</span> (reset) {
        reset = <span class="keyword">false</span>;
        tracker_features.Reset();
    }
    tracker_features.Purge();
    tracker_features.Track(img_gray);
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;tracker_features.feature_count; i++) {
        cvCircle(image, 
            cvPoint(<span class="keywordtype">int</span>(tracker_features.features[i].x), <span class="keywordtype">int</span>(tracker_features.features[i].y)), 2, 
            CV_RGB(tracker_features.ids[i]%255,(tracker_features.ids[i]*7)%255,(tracker_features.ids[i]*11)%255));
    }
}

<span class="keyword">const</span> <span class="keywordtype">int</span> nof_trackers = 6;
void (*(trackers[nof_trackers]))(IplImage *image, IplImage *img_gray) = {
    track_none,
    track_psa,
    track_psa_rot,
    track_stat,
    track_stat_rot,
    track_features,
};
<span class="keywordtype">char</span> tracker_names[nof_trackers][64]={
    <span class="stringliteral">&quot;No tracker - Press any key to change&quot;</span>,
    <span class="stringliteral">&quot;TrackerPsa&quot;</span>,
    <span class="stringliteral">&quot;TrackerPsaRot&quot;</span>,
    <span class="stringliteral">&quot;TrackerStat&quot;</span>,
    <span class="stringliteral">&quot;TrackerStatRot&quot;</span>,
    <span class="stringliteral">&quot;TrackerFeatures&quot;</span>,
};

<span class="keywordtype">void</span> videocallback(IplImage *image)
{
    assert(image);
    <span class="keyword">static</span> <a name="_a15"></a><a class="code" href="classalvar_1_1_camera.html" title="Simple Camera class for calculating distortions, orientation or projections with...">Camera</a> cam;
    <span class="keyword">static</span> IplImage *img_gray=NULL;
    <span class="keyword">static</span> <span class="keywordtype">bool</span> init=<span class="keyword">true</span>;

    <span class="keywordflow">if</span> (init) {
        init = <span class="keyword">false</span>;
        img_gray = CvTestbed::Instance().CreateImageWithProto(<span class="stringliteral">&quot;img_gray&quot;</span>, image, 0, 1);
        cout&lt;&lt;<span class="stringliteral">&quot;Loading calibration: &quot;</span>&lt;&lt;calibrationFilename.str();
        <span class="keywordflow">if</span> (cam.<a name="a16"></a><a class="code" href="classalvar_1_1_camera.html#a68c7b37ecfe0ab2e1d535e1c73f79ac6" title="Set the calibration file and the current resolution for which the calibration is...">SetCalib</a>(calibrationFilename.str().c_str(), image-&gt;width, image-&gt;height)) {
            cout&lt;&lt;<span class="stringliteral">&quot; [Ok]&quot;</span>&lt;&lt;endl;
        } 
        <span class="keywordflow">else</span> {
            cam.<a name="a17"></a><a class="code" href="classalvar_1_1_camera.html#a7156e68d6b50af62aef36e538964a7a8" title="If we have no calibration file we can still adjust the default calibration to current...">SetRes</a>(image-&gt;width, image-&gt;height);
            cout&lt;&lt;<span class="stringliteral">&quot; [Fail]&quot;</span>&lt;&lt;endl;
        }
    }
    <span class="keywordflow">if</span> (image-&gt;nChannels == 1) cvCopy(image, img_gray);
    <span class="keywordflow">else</span> cvCvtColor(image, img_gray, CV_RGB2GRAY);

    trackers[tracker](image, img_gray);
    cvPutText(image, tracker_names[tracker], cvPoint(3, image-&gt;height - 20), &amp;font, CV_RGB(255, 255, 255));
}

<span class="keywordtype">int</span> keycallback(<span class="keywordtype">int</span> key) {
    <span class="keywordflow">if</span> ((key == <span class="charliteral">&#39;r&#39;</span>) || (key == <span class="charliteral">&#39;t&#39;</span>)) {
        reset = <span class="keyword">true</span>;
        <span class="keywordflow">return</span> 0;
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((key == <span class="charliteral">&#39;n&#39;</span>) || (key == <span class="charliteral">&#39; &#39;</span>)){
        tracker = ((tracker+1)%nof_trackers);
        reset = <span class="keyword">true</span>;
        <span class="keywordflow">return</span> 0;
    }
    <span class="keywordflow">return</span> key;
}

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])
{
    <span class="keywordflow">try</span> {
        <span class="comment">// Output usage message</span>
        std::string filename(argv[0]);
        filename = filename.substr(filename.find_last_of(<span class="charliteral">&#39;\\&#39;</span>) + 1);
        std::cout &lt;&lt; <span class="stringliteral">&quot;SampleTrack&quot;</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;===========&quot;</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;Description:&quot;</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;  This is an example of how to use the &#39;TrackerPsa&#39;, &#39;TrackerPsaRot&#39;,&quot;</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;  &#39;TrackerFeatures&#39;, &#39;TrackerStat&#39; and &#39;TrackerStatRot&#39; classes to&quot;</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;  track the optical flow of the video.&quot;</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;Usage:&quot;</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; filename &lt;&lt; <span class="stringliteral">&quot; [device]&quot;</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;    device    integer selecting device from enumeration list (default 0)&quot;</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;              highgui capture devices are prefered&quot;</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;Keyboard Shortcuts:&quot;</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;  r,t: reset tracker&quot;</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;  n,space: cycle through tracking algorithms&quot;</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;  q: quit&quot;</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; std::endl;

        <span class="comment">// Initialize font</span>
        cvInitFont(&amp;font, CV_FONT_HERSHEY_PLAIN, 1.0, 1.0);

        <span class="comment">// Initialise CvTestbed</span>
        CvTestbed::Instance().SetVideoCallback(videocallback);
        CvTestbed::Instance().SetKeyCallback(keycallback);

        <span class="comment">// Enumerate possible capture plugins</span>
        CaptureFactory::CapturePluginVector plugins = CaptureFactory::instance()-&gt;enumeratePlugins();
        <span class="keywordflow">if</span> (plugins.size() &lt; 1) {
            std::cout &lt;&lt; <span class="stringliteral">&quot;Could not find any capture plugins.&quot;</span> &lt;&lt; std::endl;
            <span class="keywordflow">return</span> 0;
        }

        <span class="comment">// Display capture plugins</span>
        std::cout &lt;&lt; <span class="stringliteral">&quot;Available Plugins: &quot;</span>;
        outputEnumeratedPlugins(plugins);
        std::cout &lt;&lt; std::endl;

        <span class="comment">// Enumerate possible capture devices</span>
        CaptureFactory::CaptureDeviceVector devices = CaptureFactory::instance()-&gt;enumerateDevices();
        <span class="keywordflow">if</span> (devices.size() &lt; 1) {
            std::cout &lt;&lt; <span class="stringliteral">&quot;Could not find any capture devices.&quot;</span> &lt;&lt; std::endl;
            <span class="keywordflow">return</span> 0;
        }

        <span class="comment">// Check command line argument for which device to use</span>
        <span class="keywordtype">int</span> selectedDevice = defaultDevice(devices);
        <span class="keywordflow">if</span> (argc &gt; 1) {
            selectedDevice = atoi(argv[1]);
        }
        <span class="keywordflow">if</span> (selectedDevice &gt;= (<span class="keywordtype">int</span>)devices.size()) {
            selectedDevice = defaultDevice(devices);
        }
        
        <span class="comment">// Display capture devices</span>
        std::cout &lt;&lt; <span class="stringliteral">&quot;Enumerated Capture Devices:&quot;</span> &lt;&lt; std::endl;
        outputEnumeratedDevices(devices, selectedDevice);
        std::cout &lt;&lt; std::endl;
        
        <span class="comment">// Create capture object from camera</span>
        <a name="_a18"></a><a class="code" href="classalvar_1_1_capture.html" title="Capture interface that plugins must implement.">Capture</a> *cap = CaptureFactory::instance()-&gt;createCapture(devices[selectedDevice]);
        std::string uniqueName = devices[selectedDevice].uniqueName();

        <span class="comment">// Handle capture lifecycle and start video capture</span>
        <span class="comment">// Note that loadSettings/saveSettings are not supported by all plugins</span>
        <span class="keywordflow">if</span> (cap) {
            std::stringstream settingsFilename;
            settingsFilename &lt;&lt; <span class="stringliteral">&quot;camera_settings_&quot;</span> &lt;&lt; uniqueName &lt;&lt; <span class="stringliteral">&quot;.xml&quot;</span>;
            calibrationFilename &lt;&lt; <span class="stringliteral">&quot;camera_calibration_&quot;</span> &lt;&lt; uniqueName &lt;&lt; <span class="stringliteral">&quot;.xml&quot;</span>;
            
            cap-&gt;<a name="a19"></a><a class="code" href="classalvar_1_1_capture.html#ad64c54ab3191981b2443c47007f38516" title="Starts the camera capture.">start</a>();
            cap-&gt;<a name="a20"></a><a class="code" href="classalvar_1_1_capture.html#a7128319289dbf3e2847252407a636bf6" title="Set the resolution.">setResolution</a>(640, 480);
            
            <span class="keywordflow">if</span> (cap-&gt;<a name="a21"></a><a class="code" href="classalvar_1_1_capture.html#a485254ebd020e4976fe6ee8fbe14c964" title="Load camera settings from a file.">loadSettings</a>(settingsFilename.str())) {
                std::cout &lt;&lt; <span class="stringliteral">&quot;Loading settings: &quot;</span> &lt;&lt; settingsFilename.str() &lt;&lt; std::endl;
            }

            std::stringstream title;
            title &lt;&lt; <span class="stringliteral">&quot;SampleTrack (&quot;</span> &lt;&lt; cap-&gt;<a name="a22"></a><a class="code" href="classalvar_1_1_capture.html#acf46a70c9622fe7423877992d4cce3a8" title="The camera information associated to this capture object.">captureDevice</a>().<a name="a23"></a><a class="code" href="classalvar_1_1_capture_device.html#a11c32e9333ba254fb56e624f5f6fcade" title="The type of capture backend.">captureType</a>() &lt;&lt; <span class="stringliteral">&quot;)&quot;</span>;

            CvTestbed::Instance().StartVideo(cap, title.str().c_str());

            <span class="keywordflow">if</span> (cap-&gt;<a name="a24"></a><a class="code" href="classalvar_1_1_capture.html#af0e390628a628c31dce4bc8f48f7b847" title="Save camera settings to a file.">saveSettings</a>(settingsFilename.str())) {
                std::cout &lt;&lt; <span class="stringliteral">&quot;Saving settings: &quot;</span> &lt;&lt; settingsFilename.str() &lt;&lt; std::endl;
            }

            cap-&gt;<a name="a25"></a><a class="code" href="classalvar_1_1_capture.html#a0efff8623a2fb79dad94a96dcf16d966" title="Stops the camera capture.">stop</a>();
            <span class="keyword">delete</span> cap;
        }
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (CvTestbed::Instance().StartVideo(0, argv[0])) {
        }
        <span class="keywordflow">else</span> {
            std::cout &lt;&lt; <span class="stringliteral">&quot;Could not initialize the selected capture backend.&quot;</span> &lt;&lt; std::endl;
        }

        <span class="keywordflow">return</span> 0;
    }
    <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception &amp;e) {
        std::cout &lt;&lt; <span class="stringliteral">&quot;Exception: &quot;</span> &lt;&lt; e.what() &lt;&lt; endl;
    }
    <span class="keywordflow">catch</span> (...) {
        std::cout &lt;&lt; <span class="stringliteral">&quot;Exception: unknown&quot;</span> &lt;&lt; std::endl;
    }
}
</pre></div> </div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Tue May 29 18:20:30 2012 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
