<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>UnscentedKalman Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespacealvar.html">alvar</a>::<a class="el" href="classalvar_1_1_unscented_kalman.html">UnscentedKalman</a>
  </div>
</div>
<div class="contents">
<h1>UnscentedKalman Class Reference</h1><!-- doxytag: class="alvar::UnscentedKalman" -->
<p>Implementation of unscented kalman filter (UKF) for filtering non-linear processes.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_unscented_kalman_8h_source.html">UnscentedKalman.h</a>&gt;</code></p>

<p><a href="classalvar_1_1_unscented_kalman-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_unscented_kalman.html#a1b2459167408236b993df34fa53fc446">UnscentedKalman</a> (int state_n, int obs_n, int state_k=0, double alpha=0.001, double beta=2.0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes Unscented <a class="el" href="classalvar_1_1_kalman.html" title="Kalman implementation.">Kalman</a> filter.  <a href="#a1b2459167408236b993df34fa53fc446"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CvMat *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_unscented_kalman.html#a118419b24e76e50de95a61d30dad6926">getState</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the process state vector.  <a href="#a118419b24e76e50de95a61d30dad6926"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CvMat *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_unscented_kalman.html#a606734f4ed68bce3badb6cd1b62dcbd9">getStateCovariance</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the process state covariance matrix.  <a href="#a606734f4ed68bce3badb6cd1b62dcbd9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_unscented_kalman.html#a25a40b6614565f755233080a384c35f1">initialize</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">(Re-)initialize UKF internal state.  <a href="#a25a40b6614565f755233080a384c35f1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_unscented_kalman.html#ade8399568949688cd1e819c79b2bf159">predict</a> (<a class="el" href="classalvar_1_1_unscented_process.html">UnscentedProcess</a> *process_model)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Updated the state by predicting.  <a href="#ade8399568949688cd1e819c79b2bf159"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_unscented_kalman.html#a9f8534752fbe37d55088f1d7c869bf66">update</a> (<a class="el" href="classalvar_1_1_unscented_observation.html">UnscentedObservation</a> *observation)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Updates the state by an observation.  <a href="#a9f8534752fbe37d55088f1d7c869bf66"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Implementation of unscented kalman filter (UKF) for filtering non-linear processes. </p>
<p>See <a href="http://www.cs.unc.edu/~welch/kalman/media/pdf/Julier1997_SPIE_KF.pdf">http://www.cs.unc.edu/~welch/kalman/media/pdf/Julier1997_SPIE_KF.pdf</a> for more details about UKF.</p>
<p>The UKF estimates a process state (represented by a vector) using observations of the process. Observations are some derivate of the process state as usually the process state cannot be directly observed.</p>
<p><em><a class="el" href="classalvar_1_1_unscented_process.html" title="Process model for an unscented kalman filter.">UnscentedProcess</a></em> models the process by predicting the next filter state based on the current filter state.</p>
<p><em><a class="el" href="classalvar_1_1_unscented_observation.html" title="Observation model for an unscented kalman filter.">UnscentedObservation</a></em> models the observation by predicting observation results based on the current filter state.</p>
<p><a class="el" href="classalvar_1_1_unscented_kalman.html" title="Implementation of unscented kalman filter (UKF) for filtering non-linear processes...">UnscentedKalman</a> holds the estimated process state vector and its covariance matrix. The new process state can be estimated using <em>predict</em> and <em>update</em> methods.</p>
<p>The current implementation does not separate process noise elements from the process state vector. It is therefore the responsibility of the user to include noise terms into process state and state covariance.</p>
<div class="fragment"><pre class="fragment">   <span class="keyword">class </span>MyUnscentedProcess : <span class="keyword">public</span> UnscentedProcess {
     <span class="keywordtype">void</span> f(CvMat *state) { <span class="comment">// compute new state }</span>
     CvMat *getProcessNoise() { <span class="keywordflow">return</span> _noise; }
   } myProcess;

   <span class="keyword">class </span>MyUnscentedObservation : <span class="keyword">public</span> UnscentedObservation {
     <span class="keywordtype">void</span> h(CvMat *z, cvMat *state) { <span class="comment">// compute measurement vector z from state }</span>
     CvMat *getObservation() { <span class="keywordflow">return</span> _obs; }
     CvMat *getObservationNoise() { <span class="keywordflow">return</span> _noise; }
   } myObservation;

   <span class="keywordtype">int</span> state_n = NUMBER_OF_ELEMENTS_IN_PROCESS_STATE_VECTOR;
   <span class="keywordtype">int</span> obs_n = NUMBER_OF_ELEMENTS_IN_PROCESS_OBSERVATION_VECTOR;
   <span class="keywordtype">int</span> state_k = NUMBER_OF_PROCESS_NOISE_ELEMENTS; <span class="comment">//TODO: Not supported at the moment.</span>

   <a class="code" href="classalvar_1_1_unscented_kalman.html#a1b2459167408236b993df34fa53fc446" title="Initializes Unscented Kalman filter.">UnscentedKalman</a> ukf(state_n, obs_n, state_k);
   initializeState(ukf.getState(), ukf.getStateCovariance());
   ukf.initialize();

   <span class="keywordflow">while</span> (1) {
     ukf.predict(&amp;myProcess);
     <span class="comment">// measure new observation.</span>
     ukf.update(&amp;myObservation);
     CvMat *state = ukf.getState();
     <span class="comment">// unpack state information from the state vector and do something with it.</span>
   }
</pre></div> 
<p>Definition at line <a class="el" href="_unscented_kalman_8h_source.html#l00096">96</a> of file <a class="el" href="_unscented_kalman_8h_source.html">UnscentedKalman.h</a>.</p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a1b2459167408236b993df34fa53fc446"></a><!-- doxytag: member="alvar::UnscentedKalman::UnscentedKalman" ref="a1b2459167408236b993df34fa53fc446" args="(int state_n, int obs_n, int state_k=0, double alpha=0.001, double beta=2.0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classalvar_1_1_unscented_kalman.html">UnscentedKalman</a> </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>state_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>obs_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>state_k</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>alpha</em> = <code>0.001</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>beta</em> = <code>2.0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initializes Unscented <a class="el" href="classalvar_1_1_kalman.html" title="Kalman implementation.">Kalman</a> filter. </p>
<p>Initializes Unscented <a class="el" href="classalvar_1_1_kalman.html" title="Kalman implementation.">Kalman</a> filter. The state vector returned by <em>getState</em> and state covariance matrix returned by <em>getStateCovariance</em> should be initialized before using the filter.</p>
<p>Separate state noise vector is currently unsupported. The user should include noise terms in the state vector directly. Set the noise mean into state vector and noise variance into state covariance matrix.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>state_n</em>&nbsp;</td><td>The number of elements in process state vector. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>obs_n</em>&nbsp;</td><td>The number of elements in observation vector. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>state_k</em>&nbsp;</td><td>The number of noise elements used in the process model. TODO: This is currently unsupported. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alpha</em>&nbsp;</td><td>Spread of sigma points. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>beta</em>&nbsp;</td><td>Prior knowlegde about the distribution (2 for Gaussian). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a118419b24e76e50de95a61d30dad6926"></a><!-- doxytag: member="alvar::UnscentedKalman::getState" ref="a118419b24e76e50de95a61d30dad6926" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CvMat* getState </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the process state vector. </p>
<p>The returned state vector contains the current state of the process. The returned vector may be modified if the current process state is known, for example in initialization phase. If the vector is modified, <em>initialize</em> method must be called before calling either predict or update methods.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A vector of state_n elements. </dd></dl>

<p>Definition at line <a class="el" href="_unscented_kalman_8h_source.html#l00173">173</a> of file <a class="el" href="_unscented_kalman_8h_source.html">UnscentedKalman.h</a>.</p>

</div>
</div>
<a class="anchor" id="a606734f4ed68bce3badb6cd1b62dcbd9"></a><!-- doxytag: member="alvar::UnscentedKalman::getStateCovariance" ref="a606734f4ed68bce3badb6cd1b62dcbd9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CvMat* getStateCovariance </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the process state covariance matrix. </p>
<p>The returned matrix contains the current state covariance. The matrix may be modified if the covariance is known, for example in initialization phase. If the matrix is modified, <em>initialize</em> method must be called before calling either predict of update methods.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>state_n by state_n covariance matrix. </dd></dl>

<p>Definition at line <a class="el" href="_unscented_kalman_8h_source.html#l00184">184</a> of file <a class="el" href="_unscented_kalman_8h_source.html">UnscentedKalman.h</a>.</p>

</div>
</div>
<a class="anchor" id="a25a40b6614565f755233080a384c35f1"></a><!-- doxytag: member="alvar::UnscentedKalman::initialize" ref="a25a40b6614565f755233080a384c35f1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initialize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>(Re-)initialize UKF internal state. </p>
<p>Must be called before predict/update when ever state or state co-variance are changed. </p>

</div>
</div>
<a class="anchor" id="ade8399568949688cd1e819c79b2bf159"></a><!-- doxytag: member="alvar::UnscentedKalman::predict" ref="ade8399568949688cd1e819c79b2bf159" args="(UnscentedProcess *process_model)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void predict </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalvar_1_1_unscented_process.html">UnscentedProcess</a> *&nbsp;</td>
          <td class="paramname"> <em>process_model</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Updated the state by predicting. </p>
<p>Updates the process state by predicting new state from the current state. Normally each predict call is followed with a call to update method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>process_model</em>&nbsp;</td><td>The model implementation that is used to predict the next state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9f8534752fbe37d55088f1d7c869bf66"></a><!-- doxytag: member="alvar::UnscentedKalman::update" ref="a9f8534752fbe37d55088f1d7c869bf66" args="(UnscentedObservation *observation)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalvar_1_1_unscented_observation.html">UnscentedObservation</a> *&nbsp;</td>
          <td class="paramname"> <em>observation</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Updates the state by an observation. </p>
<p>Updates the process state by a measurement that indirectly observed the correct process state. The observation implementation needs to hold the current measurement data and implement a transformation from process state into measurement (the <em><a class="el" href="classalvar_1_1_unscented_observation.html#a62f35b43622eede556ddf45b071d5d90" title="observation model: z = h(state)">UnscentedObservation::h</a></em> method).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>observation</em>&nbsp;</td><td>The observation implementation the is used to update the current state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_unscented_kalman_8h_source.html">UnscentedKalman.h</a></li>
</ul>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Tue May 29 18:20:30 2012 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
