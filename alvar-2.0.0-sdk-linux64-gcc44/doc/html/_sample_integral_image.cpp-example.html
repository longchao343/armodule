<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>SampleIntegralImage.cpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>SampleIntegralImage.cpp</h1><p>This is an example of how to use the <em>IntegralImage</em> and <em>IntegralGradient</em> classes for image gradient analysis.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &quot;CvTestbed.h&quot;</span>
<span class="preprocessor">#include &quot;<a class="code" href="_integral_image_8h.html" title="This file implements integral image and integral gradient computations.">IntegralImage.h</a>&quot;</span>
<span class="preprocessor">#include &quot;Shared.h&quot;</span>
<span class="keyword">using namespace </span>alvar;
<span class="keyword">using namespace </span>std;

<span class="keywordtype">void</span> videocallback(IplImage *image)
{
    <span class="keyword">static</span> IplImage *img_grad = NULL;
    <span class="keyword">static</span> IplImage *img_gray = NULL;
    <span class="keyword">static</span> IplImage *img_ver = NULL;
    <span class="keyword">static</span> IplImage *img_hor = NULL;
    <span class="keyword">static</span> IplImage *img_canny = NULL;
    <span class="keyword">static</span> <a name="_a0"></a><a class="code" href="classalvar_1_1_integral_image.html" title="IntegralImage is used for calculating rectangular image sums and averages rapidly...">IntegralImage</a> integ;
    <span class="keyword">static</span> <a name="_a1"></a><a class="code" href="classalvar_1_1_integral_gradient.html" title="IntegralGradient is used for calculating rectangular image gradients rapidly">IntegralGradient</a> grad;

    assert(image);
    <span class="keywordflow">if</span> (img_gray == NULL) {
        <span class="comment">// Following image is toggled visible using key &#39;0&#39;</span>
        img_grad = CvTestbed::Instance().CreateImageWithProto(<span class="stringliteral">&quot;Gradient&quot;</span>, image);
        CvTestbed::Instance().ToggleImageVisible(0);
        img_gray = CvTestbed::Instance().CreateImageWithProto(<span class="stringliteral">&quot;Grayscale&quot;</span>, image, 0, 1);
        img_ver = CvTestbed::Instance().CreateImage(<span class="stringliteral">&quot;Vertical&quot;</span>, cvSize(1,image-&gt;height), IPL_DEPTH_8U, 1);
        img_hor = CvTestbed::Instance().CreateImage(<span class="stringliteral">&quot;Horizontal&quot;</span>, cvSize(image-&gt;width,1), IPL_DEPTH_8U, 1);
        img_canny = CvTestbed::Instance().CreateImageWithProto(<span class="stringliteral">&quot;Canny&quot;</span>, image, 0, 1);
        img_canny-&gt;origin = img_ver-&gt;origin = img_hor-&gt;origin = image-&gt;origin;
    }
    <span class="keywordflow">if</span> (image-&gt;nChannels &gt; 1) { 
        cvCvtColor(image, img_gray, CV_RGB2GRAY);
    } <span class="keywordflow">else</span> {
        cvCopy(image, img_gray);
    }

    <span class="comment">// Show PerformanceTimer</span>
    <span class="comment">//PerformanceTimer timer;</span>
    <span class="comment">//timer.Start();</span>

    <span class="comment">// Update the integral images</span>
    integ.<a name="a2"></a><a class="code" href="classalvar_1_1_integral_image.html#a77f4c4c6e784ebc31264a0ead95b5529" title="Update integral image for the given image.">Update</a>(img_gray);
    grad.<a name="a3"></a><a class="code" href="classalvar_1_1_integral_gradient.html#a77f4c4c6e784ebc31264a0ead95b5529" title="Update intermediate images for calculating the gradients to the given image.">Update</a>(img_gray);

    <span class="comment">// Whole image projections</span>
    integ.<a name="a4"></a><a class="code" href="classalvar_1_1_integral_image.html#ae4896539f4c94eba8ded518970870c22" title="Get a sub-image using integral image representation.">GetSubimage</a>(cvRect(0,0,image-&gt;width,image-&gt;height), img_ver);
    integ.<a class="code" href="classalvar_1_1_integral_image.html#ae4896539f4c94eba8ded518970870c22" title="Get a sub-image using integral image representation.">GetSubimage</a>(cvRect(0,0,image-&gt;width,image-&gt;height), img_hor);
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y=1; y&lt;image-&gt;height; y++) {
        cvLine(image, 
               cvPoint(<span class="keywordtype">int</span>(cvGet2D(img_ver, y-1, 0).val[0]), y-1), 
               cvPoint(<span class="keywordtype">int</span>(cvGet2D(img_ver, y, 0).val[0]), y), 
               CV_RGB(255,0,0));
    }
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x=1; x&lt;image-&gt;width; x++) {
        cvLine(image, 
               cvPoint(x-1, <span class="keywordtype">int</span>(cvGet2D(img_hor, 0, x-1).val[0])), 
               cvPoint(x, <span class="keywordtype">int</span>(cvGet2D(img_hor, 0, x).val[0])), 
               CV_RGB(0,255,0));
    }

    <span class="comment">// Gradients</span>
    <span class="comment">// Mark gradients for 4x4 sub-blocks</span>
    <span class="comment">/*</span>
<span class="comment">    cvZero(img_grad);</span>
<span class="comment">    CvRect r = {0,0,4,4};</span>
<span class="comment">    for (int y=0; y&lt;image-&gt;height/4; y++) {</span>
<span class="comment">        r.y = y*4;</span>
<span class="comment">        for (int x=0; x&lt;image-&gt;width/4; x++) {</span>
<span class="comment">            r.x = x*4;</span>
<span class="comment">            double dirx, diry;</span>
<span class="comment">            grad.GetAveGradient(r, &amp;dirx, &amp;diry);</span>
<span class="comment">            cvLine(img_grad, cvPoint(r.x+2,r.y+2), cvPoint(r.x+2+int(dirx),r.y+2+int(diry)), CV_RGB(255,0,0));</span>
<span class="comment">        }</span>
<span class="comment">    }</span>
<span class="comment">    */</span>

    <span class="comment">// Gradients on canny</span>
    cvZero(img_grad);
    <span class="keyword">static</span> <span class="keywordtype">int</span> t1=64, t2=192;
    cvCreateTrackbar(<span class="stringliteral">&quot;t1&quot;</span>, <span class="stringliteral">&quot;Gradient&quot;</span>, &amp;t1, 255, NULL);
    cvCreateTrackbar(<span class="stringliteral">&quot;t2&quot;</span>, <span class="stringliteral">&quot;Gradient&quot;</span>, &amp;t2, 255, NULL);
    cvCanny(img_gray, img_canny, t1, t2);
    CvRect r = {0,0,4,4};
    <span class="keywordflow">for</span> (r.y=0; r.y&lt;img_canny-&gt;height-4; r.y++) {
        <span class="keywordflow">for</span> (r.x=0; r.x&lt;img_canny-&gt;width-4; r.x++) {
            <span class="keywordflow">if</span> (img_canny-&gt;imageData[r.y*img_canny-&gt;widthStep+r.x]) {
                <span class="keywordtype">double</span> dirx, diry;
                grad.<a name="a5"></a><a class="code" href="classalvar_1_1_integral_gradient.html#a9ad1dc54e3d92a0e2b301d8dd6cc0d1a" title="Calculate the average gradient for the given rectangular area in the image.">GetAveGradient</a>(r, &amp;dirx, &amp;diry);
                cvLine(img_grad, cvPoint(r.x+2,r.y+2), cvPoint(r.x+2+<span class="keywordtype">int</span>(dirx),r.y+2+<span class="keywordtype">int</span>(diry)), CV_RGB(0,0,255));
                cvLine(img_grad, cvPoint(r.x+2,r.y+2), cvPoint(r.x+2+<span class="keywordtype">int</span>(-diry),r.y+2+<span class="keywordtype">int</span>(+dirx)), CV_RGB(255,0,0));
                cvLine(img_grad, cvPoint(r.x+2,r.y+2), cvPoint(r.x+2+<span class="keywordtype">int</span>(+diry),r.y+2+<span class="keywordtype">int</span>(-dirx)), CV_RGB(255,0,0));
            }
        }
    }

    <span class="comment">// Show PerformanceTimer</span>
    <span class="comment">//cout&lt;&lt;&quot;Processing: &quot;&lt;&lt;1.0 / timer.Stop()&lt;&lt;&quot; fps&quot;&lt;&lt;endl;</span>
}

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])
{
    <span class="keywordflow">try</span> {
        <span class="comment">// Output usage message</span>
        std::string filename(argv[0]);
        filename = filename.substr(filename.find_last_of(<span class="charliteral">&#39;\\&#39;</span>) + 1);
        std::cout &lt;&lt; <span class="stringliteral">&quot;SampleIntegralImage&quot;</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;===================&quot;</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;Description:&quot;</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;  This is an example of how to use the &#39;IntegralImage&#39; and&quot;</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;  &#39;IntegralGradient&#39; classes. The vertical (green) and horizontal (red)&quot;</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;  whole image projections are computed using &#39;IntegralImage::GetSubimage&#39;&quot;</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;  and shown in the SampleIntegralImage window. The gradients of the&quot;</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;  image edges are shown in the Gradient window. The edges are detected&quot;</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;  using the Canny edge detector where t1 and t2 are parameters for the&quot;</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;  Canny algorithm. The gradients are drawn in red and their local normals&quot;</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;  are drawn in blue.&quot;</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;Usage:&quot;</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; filename &lt;&lt; <span class="stringliteral">&quot; [device]&quot;</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;    device    integer selecting device from enumeration list (default 0)&quot;</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;              highgui capture devices are prefered&quot;</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;Keyboard Shortcuts:&quot;</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;  0: show/hide gradient image&quot;</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;  1: show/hide grayscale image&quot;</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;  2: show/hide vertical image&quot;</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;  3: show/hide horizontal image&quot;</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;  4: show/hide canny image&quot;</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;  q: quit&quot;</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; std::endl;

        <span class="comment">// Initialise CvTestbed</span>
        CvTestbed::Instance().SetVideoCallback(videocallback);

        <span class="comment">// Enumerate possible capture plugins</span>
        CaptureFactory::CapturePluginVector plugins = CaptureFactory::instance()-&gt;enumeratePlugins();
        <span class="keywordflow">if</span> (plugins.size() &lt; 1) {
            std::cout &lt;&lt; <span class="stringliteral">&quot;Could not find any capture plugins.&quot;</span> &lt;&lt; std::endl;
            <span class="keywordflow">return</span> 0;
        }

        <span class="comment">// Display capture plugins</span>
        std::cout &lt;&lt; <span class="stringliteral">&quot;Available Plugins: &quot;</span>;
        outputEnumeratedPlugins(plugins);
        std::cout &lt;&lt; std::endl;

        <span class="comment">// Enumerate possible capture devices</span>
        CaptureFactory::CaptureDeviceVector devices = CaptureFactory::instance()-&gt;enumerateDevices();
        <span class="keywordflow">if</span> (devices.size() &lt; 1) {
            std::cout &lt;&lt; <span class="stringliteral">&quot;Could not find any capture devices.&quot;</span> &lt;&lt; std::endl;
            <span class="keywordflow">return</span> 0;
        }

        <span class="comment">// Check command line argument for which device to use</span>
        <span class="keywordtype">int</span> selectedDevice = defaultDevice(devices);
        <span class="keywordflow">if</span> (argc &gt; 1) {
            selectedDevice = atoi(argv[1]);
        }
        <span class="keywordflow">if</span> (selectedDevice &gt;= (<span class="keywordtype">int</span>)devices.size()) {
            selectedDevice = defaultDevice(devices);
        }
        
        <span class="comment">// Display capture devices</span>
        std::cout &lt;&lt; <span class="stringliteral">&quot;Enumerated Capture Devices:&quot;</span> &lt;&lt; std::endl;
        outputEnumeratedDevices(devices, selectedDevice);
        std::cout &lt;&lt; std::endl;
        
        <span class="comment">// Create capture object from camera</span>
        <a name="_a6"></a><a class="code" href="classalvar_1_1_capture.html" title="Capture interface that plugins must implement.">Capture</a> *cap = CaptureFactory::instance()-&gt;createCapture(devices[selectedDevice]);
        std::string uniqueName = devices[selectedDevice].uniqueName();

        <span class="comment">// Handle capture lifecycle and start video capture</span>
        <span class="comment">// Note that loadSettings/saveSettings are not supported by all plugins</span>
        <span class="keywordflow">if</span> (cap) {
            std::stringstream settingsFilename;
            settingsFilename &lt;&lt; <span class="stringliteral">&quot;camera_settings_&quot;</span> &lt;&lt; uniqueName &lt;&lt; <span class="stringliteral">&quot;.xml&quot;</span>;
            
            cap-&gt;<a name="a7"></a><a class="code" href="classalvar_1_1_capture.html#ad64c54ab3191981b2443c47007f38516" title="Starts the camera capture.">start</a>();
            cap-&gt;<a name="a8"></a><a class="code" href="classalvar_1_1_capture.html#a7128319289dbf3e2847252407a636bf6" title="Set the resolution.">setResolution</a>(640, 480);
            
            <span class="keywordflow">if</span> (cap-&gt;<a name="a9"></a><a class="code" href="classalvar_1_1_capture.html#a485254ebd020e4976fe6ee8fbe14c964" title="Load camera settings from a file.">loadSettings</a>(settingsFilename.str())) {
                std::cout &lt;&lt; <span class="stringliteral">&quot;Loading settings: &quot;</span> &lt;&lt; settingsFilename.str() &lt;&lt; std::endl;
            }

            std::stringstream title;
            title &lt;&lt; <span class="stringliteral">&quot;SampleIntegralImage (&quot;</span> &lt;&lt; cap-&gt;<a name="a10"></a><a class="code" href="classalvar_1_1_capture.html#acf46a70c9622fe7423877992d4cce3a8" title="The camera information associated to this capture object.">captureDevice</a>().<a name="a11"></a><a class="code" href="classalvar_1_1_capture_device.html#a11c32e9333ba254fb56e624f5f6fcade" title="The type of capture backend.">captureType</a>() &lt;&lt; <span class="stringliteral">&quot;)&quot;</span>;

            CvTestbed::Instance().StartVideo(cap, title.str().c_str());

            <span class="keywordflow">if</span> (cap-&gt;<a name="a12"></a><a class="code" href="classalvar_1_1_capture.html#af0e390628a628c31dce4bc8f48f7b847" title="Save camera settings to a file.">saveSettings</a>(settingsFilename.str())) {
                std::cout &lt;&lt; <span class="stringliteral">&quot;Saving settings: &quot;</span> &lt;&lt; settingsFilename.str() &lt;&lt; std::endl;
            }

            cap-&gt;<a name="a13"></a><a class="code" href="classalvar_1_1_capture.html#a0efff8623a2fb79dad94a96dcf16d966" title="Stops the camera capture.">stop</a>();
            <span class="keyword">delete</span> cap;
        }
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (CvTestbed::Instance().StartVideo(0, argv[0])) {
        }
        <span class="keywordflow">else</span> {
            std::cout &lt;&lt; <span class="stringliteral">&quot;Could not initialize the selected capture backend.&quot;</span> &lt;&lt; std::endl;
        }

        <span class="keywordflow">return</span> 0;
    }
    <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception &amp;e) {
        std::cout &lt;&lt; <span class="stringliteral">&quot;Exception: &quot;</span> &lt;&lt; e.what() &lt;&lt; endl;
    }
    <span class="keywordflow">catch</span> (...) {
        std::cout &lt;&lt; <span class="stringliteral">&quot;Exception: unknown&quot;</span> &lt;&lt; std::endl;
    }
}
</pre></div> </div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Tue May 29 18:20:30 2012 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
