<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>alvar Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="namespaces.html"><span>Namespace&nbsp;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>alvar Namespace Reference</h1>
<p>Main ALVAR namespace.  
<a href="#_details">More...</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealvar_1_1plugins.html">plugins</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Dynamically loaded plugins namespace. </p>
<br/></td></tr>
</p>
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_alvar_exception.html">AlvarException</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ALVAR exception class.  <a href="classalvar_1_1_alvar_exception.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_bitset.html">Bitset</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em><a class="el" href="classalvar_1_1_bitset.html" title="Bitset is a basic class for handling bit sequences">Bitset</a></em> is a basic class for handling bit sequences  <a href="classalvar_1_1_bitset.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_bitset_ext.html">BitsetExt</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An extended <em><a class="el" href="classalvar_1_1_bitset.html" title="Bitset is a basic class for handling bit sequences">Bitset</a></em> ( <em><a class="el" href="classalvar_1_1_bitset_ext.html" title="An extended Bitset ( BitsetExt ) for handling e.g. Hamming encoding/decoding.">BitsetExt</a></em> ) for handling e.g. Hamming encoding/decoding.  <a href="classalvar_1_1_bitset_ext.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structalvar_1_1_proj_points.html">ProjPoints</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simple structure for collecting 2D and 3D points e.g. for camera calibration.  <a href="structalvar_1_1_proj_points.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_camera.html">Camera</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simple <em><a class="el" href="classalvar_1_1_camera.html" title="Simple Camera class for calculating distortions, orientation or projections with...">Camera</a></em> class for calculating distortions, orientation or projections with pre-calibrated camera.  <a href="classalvar_1_1_camera.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structalvar_1_1_homography.html">Homography</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simple <em><a class="el" href="structalvar_1_1_homography.html" title="Simple Homography class for finding and projecting points between two planes.">Homography</a></em> class for finding and projecting points between two planes.  <a href="structalvar_1_1_homography.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_labeling.html">Labeling</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class for labeling connected components from binary image.  <a href="classalvar_1_1_labeling.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_labeling_cv_seq.html">LabelingCvSeq</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classalvar_1_1_labeling.html" title="Base class for labeling connected components from binary image.">Labeling</a> class that uses OpenCV routines to find connected components.  <a href="classalvar_1_1_labeling_cv_seq.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_container3d_sort_dist.html">Container3dSortDist</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Functor class for <em><a class="el" href="classalvar_1_1_container3d.html" title="Generic container to store any information in 3D (features, photos, ...).">Container3d</a></em> <em>Sort()</em> to sort the search base using distance to specified origin.  <a href="classalvar_1_1_container3d_sort_dist.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_container3d_sort_size.html">Container3dSortSize</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Functor class for <em><a class="el" href="classalvar_1_1_container3d.html" title="Generic container to store any information in 3D (features, photos, ...).">Container3d</a></em> <em>Sort()</em> to sort the search base using content size.  <a href="classalvar_1_1_container3d_sort_size.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_container3d_limit_dist.html">Container3dLimitDist</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Functor class for <em><a class="el" href="classalvar_1_1_container3d.html" title="Generic container to store any information in 3D (features, photos, ...).">Container3d</a></em> <em><a class="el" href="namespacealvar.html#a3b6789058826eef4625e281551dcf1dd" title="Limits a number to between two values.">Limit()</a></em> to limit the search space with distance.  <a href="classalvar_1_1_container3d_limit_dist.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_container3d.html">Container3d</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generic container to store any information in 3D (features, photos, ...).  <a href="classalvar_1_1_container3d.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_external_container.html">ExternalContainer</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Basic structure to be usable with EC methods.  <a href="classalvar_1_1_external_container.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_do_handle_test.html">DoHandleTest</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is a default functor for testing which items in the container should be handled by each method.  <a href="classalvar_1_1_do_handle_test.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_do_erase_test.html">DoEraseTest</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is default functor for testing which items in the container should be erased.  <a href="classalvar_1_1_do_erase_test.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_tracker_features_e_c.html">TrackerFeaturesEC</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Version of <em><a class="el" href="classalvar_1_1_tracker_features.html" title="TrackerFeatures tracks features using OpenCV&#39;s cvGoodFeaturesToTrack and cvCalcOpticalFlowPyrLK...">TrackerFeatures</a></em> using external container.  <a href="classalvar_1_1_tracker_features_e_c.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_camera_e_c.html">CameraEC</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Version of <em><a class="el" href="classalvar_1_1_camera.html" title="Simple Camera class for calculating distortions, orientation or projections with...">Camera</a></em> using external container.  <a href="classalvar_1_1_camera_e_c.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_marker_detector_e_c.html">MarkerDetectorEC</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Version of <em><a class="el" href="classalvar_1_1_marker_detector.html" title="MarkerDetector for detecting markers of type M ">MarkerDetector</a></em> using external container.  <a href="classalvar_1_1_marker_detector_e_c.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_multi_marker_e_c.html">MultiMarkerEC</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Version of <em><a class="el" href="classalvar_1_1_multi_marker.html" title="Base class for using MultiMarker.">MultiMarker</a></em> using external container.  <a href="classalvar_1_1_multi_marker_e_c.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_fern_classifier_wrapper.html">FernClassifierWrapper</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">FernClassifier subclass that implements binary reading and writting.  <a href="classalvar_1_1_fern_classifier_wrapper.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_fern_image_detector.html">FernImageDetector</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Image detector based on a Fern classifier.  <a href="classalvar_1_1_fern_image_detector.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_fern_pose_estimator.html">FernPoseEstimator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classalvar_1_1_pose.html" title="Pose representation derived from the Rotation class">Pose</a> estimation class for <a class="el" href="classalvar_1_1_fern_image_detector.html" title="Image detector based on a Fern classifier.">FernImageDetector</a>.  <a href="classalvar_1_1_fern_pose_estimator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_file_format_utils.html">FileFormatUtils</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Utility functions for file reading / writing.  <a href="classalvar_1_1_file_format_utils.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_filter.html">Filter</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em><a class="el" href="classalvar_1_1_filter.html" title="Filter is pure virtual class describing the basic virtual interface for all filters...">Filter</a></em> is pure virtual class describing the basic virtual interface for all filters  <a href="classalvar_1_1_filter.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_filter_average.html">FilterAverage</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em><a class="el" href="classalvar_1_1_filter_average.html" title="FilterAverage provides an average filter">FilterAverage</a></em> provides an average filter  <a href="classalvar_1_1_filter_average.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_filter_median.html">FilterMedian</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em><a class="el" href="classalvar_1_1_filter_median.html" title="FilterMedian provides an median filter">FilterMedian</a></em> provides an median filter  <a href="classalvar_1_1_filter_median.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_filter_running_average.html">FilterRunningAverage</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em><a class="el" href="classalvar_1_1_filter_running_average.html" title="FilterRunningAverage provides an weighted running average filter">FilterRunningAverage</a></em> provides an weighted running average filter  <a href="classalvar_1_1_filter_running_average.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_filter_double_exponential_smoothing.html">FilterDoubleExponentialSmoothing</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em><a class="el" href="classalvar_1_1_filter_double_exponential_smoothing.html" title="FilterDoubleExponentialSmoothing provides an weighted running average filter">FilterDoubleExponentialSmoothing</a></em> provides an weighted running average filter  <a href="classalvar_1_1_filter_double_exponential_smoothing.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_filter_array.html">FilterArray</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class for handling an array of filtered values.  <a href="classalvar_1_1_filter_array.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_int_index.html">IntIndex</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class for calculating "evenly spaced" integer indices for data sequence.  <a href="classalvar_1_1_int_index.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_integral_image.html">IntegralImage</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em><a class="el" href="classalvar_1_1_integral_image.html" title="IntegralImage is used for calculating rectangular image sums and averages rapidly...">IntegralImage</a></em> is used for calculating rectangular image sums and averages rapidly  <a href="classalvar_1_1_integral_image.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_integral_gradient.html">IntegralGradient</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em><a class="el" href="classalvar_1_1_integral_gradient.html" title="IntegralGradient is used for calculating rectangular image gradients rapidly">IntegralGradient</a></em> is used for calculating rectangular image gradients rapidly  <a href="classalvar_1_1_integral_gradient.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_kalman_sensor_core.html">KalmanSensorCore</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Core implementation for <a class="el" href="classalvar_1_1_kalman.html" title="Kalman implementation.">Kalman</a> sensor.  <a href="classalvar_1_1_kalman_sensor_core.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_kalman_core.html">KalmanCore</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Core implementation for <a class="el" href="classalvar_1_1_kalman.html" title="Kalman implementation.">Kalman</a>.  <a href="classalvar_1_1_kalman_core.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_kalman_sensor.html">KalmanSensor</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classalvar_1_1_kalman.html" title="Kalman implementation.">Kalman</a> sensor implementation.  <a href="classalvar_1_1_kalman_sensor.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_kalman.html">Kalman</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classalvar_1_1_kalman.html" title="Kalman implementation.">Kalman</a> implementation.  <a href="classalvar_1_1_kalman.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_kalman_sensor_ekf.html">KalmanSensorEkf</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extended <a class="el" href="classalvar_1_1_kalman.html" title="Kalman implementation.">Kalman</a> <a class="el" href="classalvar_1_1_filter.html" title="Filter is pure virtual class describing the basic virtual interface for all filters...">Filter</a> (EKF) sensor implementation.  <a href="classalvar_1_1_kalman_sensor_ekf.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_kalman_ekf.html">KalmanEkf</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extended <a class="el" href="classalvar_1_1_kalman.html" title="Kalman implementation.">Kalman</a> <a class="el" href="classalvar_1_1_filter.html" title="Filter is pure virtual class describing the basic virtual interface for all filters...">Filter</a> (EKF) implementation.  <a href="classalvar_1_1_kalman_ekf.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_kalman_visualize.html">KalmanVisualize</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class for visualizing <a class="el" href="classalvar_1_1_kalman.html" title="Kalman implementation.">Kalman</a> filter.  <a href="classalvar_1_1_kalman_visualize.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structalvar_1_1_line.html">Line</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Struct representing a line. The line is parametrized by its center and direction vector.  <a href="structalvar_1_1_line.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_marker.html">Marker</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Basic 2D <em><a class="el" href="classalvar_1_1_marker.html" title="Basic 2D Marker functionality.">Marker</a></em> functionality.  <a href="classalvar_1_1_marker.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_marker_artoolkit.html">MarkerArtoolkit</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em><a class="el" href="classalvar_1_1_marker_artoolkit.html" title="MarkerArtoolkit for using matrix markers similar with the ones used in ARToolkit...">MarkerArtoolkit</a></em> for using matrix markers similar with the ones used in ARToolkit.  <a href="classalvar_1_1_marker_artoolkit.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_marker_data.html">MarkerData</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em><a class="el" href="classalvar_1_1_marker_data.html" title="MarkerData contains matrix of Hamming encoded data.">MarkerData</a></em> contains matrix of Hamming encoded data.  <a href="classalvar_1_1_marker_data.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_marker_iterator.html">MarkerIterator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterator type for traversing templated <a class="el" href="classalvar_1_1_marker.html" title="Basic 2D Marker functionality.">Marker</a> vector without the template.  <a href="classalvar_1_1_marker_iterator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_marker_iterator_impl.html">MarkerIteratorImpl</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterator implementation for traversing templated <a class="el" href="classalvar_1_1_marker.html" title="Basic 2D Marker functionality.">Marker</a> vector without the template.  <a href="classalvar_1_1_marker_iterator_impl.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_marker_detector_impl.html">MarkerDetectorImpl</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Templateless version of <a class="el" href="classalvar_1_1_marker_detector.html" title="MarkerDetector for detecting markers of type M ">MarkerDetector</a>. Please use <a class="el" href="classalvar_1_1_marker_detector.html" title="MarkerDetector for detecting markers of type M ">MarkerDetector</a> instead.  <a href="classalvar_1_1_marker_detector_impl.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_marker_detector.html">MarkerDetector</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em><a class="el" href="classalvar_1_1_marker_detector.html" title="MarkerDetector for detecting markers of type M ">MarkerDetector</a></em> for detecting markers of type <em>M</em>  <a href="classalvar_1_1_marker_detector.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_multi_marker.html">MultiMarker</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class for using <a class="el" href="classalvar_1_1_multi_marker.html" title="Base class for using MultiMarker.">MultiMarker</a>.  <a href="classalvar_1_1_multi_marker.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_multi_marker_bundle.html">MultiMarkerBundle</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multi marker that uses bundle adjustment to refine the 3D positions of the markers (point cloud).  <a href="classalvar_1_1_multi_marker_bundle.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_multi_marker_filtered.html">MultiMarkerFiltered</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multi marker that is constructed by first calculating the marker poses directly relative to base marker and then filtering the results using e.g. median filter.  <a href="classalvar_1_1_multi_marker_filtered.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_multi_marker_initializer.html">MultiMarkerInitializer</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes multi marker by estimating their relative positions from one or more images.  <a href="classalvar_1_1_multi_marker_initializer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_optimization.html">Optimization</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Non-linear optimization routines. There are three methods implemented that include Gauss-Newton, Levenberg-Marquardt and Tukey m-estimator.  <a href="classalvar_1_1_optimization.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_capture.html">Capture</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classalvar_1_1_capture.html" title="Capture interface that plugins must implement.">Capture</a> interface that plugins must implement.  <a href="classalvar_1_1_capture.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_capture_device.html">CaptureDevice</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classalvar_1_1_capture_device.html" title="CaptureDevice holder for camera information.">CaptureDevice</a> holder for camera information.  <a href="classalvar_1_1_capture_device.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_capture_factory.html">CaptureFactory</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classalvar_1_1_capture_factory.html" title="CaptureFactory for creating Capture classes.">CaptureFactory</a> for creating <a class="el" href="classalvar_1_1_capture.html" title="Capture interface that plugins must implement.">Capture</a> classes.  <a href="classalvar_1_1_capture_factory.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_capture_plugin.html">CapturePlugin</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classalvar_1_1_capture_plugin.html" title="CapturePlugin interface that plugins must implement.">CapturePlugin</a> interface that plugins must implement.  <a href="classalvar_1_1_capture_plugin.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_directory_iterator.html">DirectoryIterator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classalvar_1_1_directory_iterator.html" title="DirectoryIterator for iterating over files and directories.">DirectoryIterator</a> for iterating over files and directories.  <a href="classalvar_1_1_directory_iterator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_lock.html">Lock</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classalvar_1_1_lock.html" title="Lock for simplifying mutex handling.">Lock</a> for simplifying mutex handling.  <a href="classalvar_1_1_lock.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_mutex.html">Mutex</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classalvar_1_1_mutex.html" title="Mutex for synchronizing multiple threads.">Mutex</a> for synchronizing multiple threads.  <a href="classalvar_1_1_mutex.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_plugin.html">Plugin</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classalvar_1_1_plugin.html" title="Plugin for loading dynamic libraries.">Plugin</a> for loading dynamic libraries.  <a href="classalvar_1_1_plugin.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_threads.html">Threads</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classalvar_1_1_threads.html" title="Threads vector for handling multiple threads.">Threads</a> vector for handling multiple threads.  <a href="classalvar_1_1_threads.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_timer.html">Timer</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classalvar_1_1_timer.html" title="Timer for measuring execution time.">Timer</a> for measuring execution time.  <a href="classalvar_1_1_timer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_uncopyable.html">Uncopyable</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classalvar_1_1_uncopyable.html" title="Uncopyable for preventing object copies.">Uncopyable</a> for preventing object copies.  <a href="classalvar_1_1_uncopyable.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_pose.html">Pose</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em><a class="el" href="classalvar_1_1_pose.html" title="Pose representation derived from the Rotation class">Pose</a></em> representation derived from the <em><a class="el" href="classalvar_1_1_rotation.html" title="Rotation structure and transformations between different parameterizations.">Rotation</a></em> class  <a href="classalvar_1_1_pose.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_ransac_impl.html">RansacImpl</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal implementation of RANSAC. Please use <a class="el" href="classalvar_1_1_ransac.html" title="Implementation of a general RANdom SAmple Consensus algorithm.">Ransac</a> or <a class="el" href="classalvar_1_1_index_ransac.html" title="Implementation of a general RANdom SAmple Consensus algorithm with implicit parameters...">IndexRansac</a>.  <a href="classalvar_1_1_ransac_impl.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_ransac.html">Ransac</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of a general RANdom SAmple Consensus algorithm.  <a href="classalvar_1_1_ransac.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_index_ransac.html">IndexRansac</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of a general RANdom SAmple Consensus algorithm with implicit parameters.  <a href="classalvar_1_1_index_ransac.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_rotation.html">Rotation</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em><a class="el" href="classalvar_1_1_rotation.html" title="Rotation structure and transformations between different parameterizations.">Rotation</a></em> structure and transformations between different parameterizations.  <a href="classalvar_1_1_rotation.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_simple_sf_m.html">SimpleSfM</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simple structure from motion implementation using <em><a class="el" href="classalvar_1_1_camera_e_c.html" title="Version of Camera using external container.">CameraEC</a></em> , <em><a class="el" href="classalvar_1_1_marker_detector_e_c.html" title="Version of MarkerDetector using external container.">MarkerDetectorEC</a></em> and <em><a class="el" href="classalvar_1_1_tracker_features_e_c.html" title="Version of TrackerFeatures using external container.">TrackerFeaturesEC</a></em>.  <a href="classalvar_1_1_simple_sf_m.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_tracker.html">Tracker</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pure virtual base class for tracking optical flow.  <a href="classalvar_1_1_tracker.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_tracker_features.html">TrackerFeatures</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em><a class="el" href="classalvar_1_1_tracker_features.html" title="TrackerFeatures tracks features using OpenCV&#39;s cvGoodFeaturesToTrack and cvCalcOpticalFlowPyrLK...">TrackerFeatures</a></em> tracks features using OpenCV's cvGoodFeaturesToTrack and cvCalcOpticalFlowPyrLK  <a href="classalvar_1_1_tracker_features.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_tracker_orientation.html">TrackerOrientation</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Track orientation based only on features in the image plane.  <a href="classalvar_1_1_tracker_orientation.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_tracker_psa.html">TrackerPsa</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em><a class="el" href="classalvar_1_1_tracker_psa.html" title="TrackerPsa implements a very simple PSA tracker">TrackerPsa</a></em> implements a very simple PSA tracker  <a href="classalvar_1_1_tracker_psa.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_tracker_psa_rot.html">TrackerPsaRot</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em><a class="el" href="classalvar_1_1_tracker_psa_rot.html" title="TrackerPsaRot implements a slightly extended version of a TrackerPsa which can also...">TrackerPsaRot</a></em> implements a slightly extended version of a <em><a class="el" href="classalvar_1_1_tracker_psa.html" title="TrackerPsa implements a very simple PSA tracker">TrackerPsa</a></em> which can also detect sideways rotation  <a href="classalvar_1_1_tracker_psa_rot.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_tracker_stat.html">TrackerStat</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em><a class="el" href="classalvar_1_1_tracker_stat.html" title="TrackerStat deduces the optical flow based on tracked features using Seppo Valli&#39;s...">TrackerStat</a></em> deduces the optical flow based on tracked features using Seppo Valli's statistical tracking.  <a href="classalvar_1_1_tracker_stat.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_tracker_stat_rot.html">TrackerStatRot</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classalvar_1_1_tracker_stat_rot.html" title="TrackerStatRot implements a slightly extended version of TrackerStat which can also...">TrackerStatRot</a> implements a slightly extended version of <a class="el" href="classalvar_1_1_tracker_stat.html" title="TrackerStat deduces the optical flow based on tracked features using Seppo Valli&#39;s...">TrackerStat</a> which can also detect sideways rotation.  <a href="classalvar_1_1_tracker_stat_rot.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_trifocal_tensor.html">TrifocalTensor</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Trifocal tensor works for three images like a fundamental matrix works for two images.  <a href="classalvar_1_1_trifocal_tensor.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_unscented_kalman.html">UnscentedKalman</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of unscented kalman filter (UKF) for filtering non-linear processes.  <a href="classalvar_1_1_unscented_kalman.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_unscented_process.html">UnscentedProcess</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Process model for an unscented kalman filter.  <a href="classalvar_1_1_unscented_process.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_unscented_observation.html">UnscentedObservation</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Observation model for an unscented kalman filter.  <a href="classalvar_1_1_unscented_observation.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structalvar_1_1_point.html">Point</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simple <em><a class="el" href="structalvar_1_1_point.html" title="Simple Point class meant to be inherited from OpenCV point-classes. For example:...">Point</a></em> class meant to be inherited from OpenCV point-classes. For example: <a class="el" href="structalvar_1_1_point.html">Point&lt;CvPoint2D64f&gt;</a> p.  <a href="structalvar_1_1_point.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structalvar_1_1_index.html">Index</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class for N-dimensional index to be used e.g. with STL maps.  <a href="structalvar_1_1_index.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_histogram.html">Histogram</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class for N-dimensional Histograms.  <a href="classalvar_1_1_histogram.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_histogram_subpixel.html">HistogramSubpixel</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">N-dimensional Histograms calculating also the subpixel average for max bin.  <a href="classalvar_1_1_histogram_subpixel.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalvar_1_1_serialization.html">Serialization</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class for serializing class content to/from file or std::iostream.  <a href="classalvar_1_1_serialization.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e33f89141a4ff02e84359a5e73544c9"></a><!-- doxytag: member="alvar::PointInt" ref="a6e33f89141a4ff02e84359a5e73544c9" args="" -->
typedef ALVAR_EXPORT <a class="el" href="structalvar_1_1_point.html">Point</a><br class="typebreak"/>
&lt; CvPoint &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealvar.html#a6e33f89141a4ff02e84359a5e73544c9">PointInt</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The default integer point type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea7817f5f6f2ed4f212dbd12e78632a7"></a><!-- doxytag: member="alvar::PointDouble" ref="aea7817f5f6f2ed4f212dbd12e78632a7" args="" -->
typedef ALVAR_EXPORT <a class="el" href="structalvar_1_1_point.html">Point</a><br class="typebreak"/>
&lt; CvPoint2D64f &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealvar.html#aea7817f5f6f2ed4f212dbd12e78632a7">PointDouble</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The default double point type. <br/></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealvar.html#a89021fa008d0a93e735361ed4f3b885f">FILE_FORMAT</a> { <a class="el" href="namespacealvar.html#a89021fa008d0a93e735361ed4f3b885fabc1b8eac28182f50a5dadf8bd06f7cf2">FILE_FORMAT_DEFAULT</a>, 
<a class="el" href="namespacealvar.html#a89021fa008d0a93e735361ed4f3b885fa7b691a0a33e305edaa80da4d7626102a">FILE_FORMAT_OPENCV</a>, 
<a class="el" href="namespacealvar.html#a89021fa008d0a93e735361ed4f3b885fab45b29c2d23300541c899f7ae91b393f">FILE_FORMAT_TEXT</a>, 
<a class="el" href="namespacealvar.html#a89021fa008d0a93e735361ed4f3b885fa564f979051988b03ce9a266ee69bbe04">FILE_FORMAT_XML</a>
 }</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class PointType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacealvar.html#a3fc556ad55fc084e9de1ee6668d75c18">DrawBB</a> (IplImage *image, const std::vector&lt; PointType &gt; &amp;points, CvScalar color, std::string label=&quot;&quot;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draws the bounding box of a connected component (Blob).  <a href="#a3fc556ad55fc084e9de1ee6668d75c18"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void ALVAR_EXPORT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealvar.html#aba302fe494ca21b2f29bcd93cbe6bc2c">DrawPoints</a> (IplImage *image, const std::vector&lt; CvPoint &gt; &amp;points, CvScalar color)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draws a set of points.  <a href="#aba302fe494ca21b2f29bcd93cbe6bc2c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class PointType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacealvar.html#a364de71f15f15353b2a1ac8a44d58b12">DrawLines</a> (IplImage *image, const std::vector&lt; PointType &gt; &amp;points, CvScalar color, bool loop=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draws lines between consecutive points stored in vector (polyline).  <a href="#a364de71f15f15353b2a1ac8a44d58b12"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void ALVAR_EXPORT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealvar.html#a3765e40337ee76458a5978e34fa08742">DrawLine</a> (IplImage *image, const <a class="el" href="structalvar_1_1_line.html">Line</a> line, CvScalar color=CV_RGB(0, 255, 0))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draws a line.  <a href="#a3765e40337ee76458a5978e34fa08742"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void ALVAR_EXPORT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealvar.html#a077b3694a57b120485fe577d01602620">DrawPoints</a> (IplImage *image, const CvSeq *contour, CvScalar color=CV_RGB(255, 0, 0))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draws points of the contour that is obtained by <em><a class="el" href="classalvar_1_1_labeling.html" title="Base class for labeling connected components from binary image.">Labeling</a></em> class.  <a href="#a077b3694a57b120485fe577d01602620"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void ALVAR_EXPORT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealvar.html#ab3bba4775c2aee2e903df3315a2b7aa2">DrawCircles</a> (IplImage *image, const CvSeq *contour, int radius, CvScalar color=CV_RGB(255, 0, 0))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draws circles to the contour points that are obtained by <em><a class="el" href="classalvar_1_1_labeling.html" title="Base class for labeling connected components from binary image.">Labeling</a></em> class.  <a href="#ab3bba4775c2aee2e903df3315a2b7aa2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void ALVAR_EXPORT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealvar.html#a21176cd4aef32ec8a32e35c9d5643e08">DrawLines</a> (IplImage *image, const CvSeq *contour, CvScalar color=CV_RGB(255, 0, 0))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draws lines between consecutive contour points.  <a href="#a21176cd4aef32ec8a32e35c9d5643e08"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class PointType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacealvar.html#a3a4da86635d9fe87a82c6d587fcb9d0f">DrawPoints</a> (IplImage *image, const std::vector&lt; PointType &gt; &amp;points, CvScalar color, int radius=1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draws circles to the array of points.  <a href="#a3a4da86635d9fe87a82c6d587fcb9d0f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void ALVAR_EXPORT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealvar.html#a0bdb9a2950fb73bcb5336594ba47d32f">DrawCVEllipse</a> (IplImage *image, CvBox2D &amp;ellipse, CvScalar color, bool fill=false, double par=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draws OpenCV ellipse.  <a href="#a0bdb9a2950fb73bcb5336594ba47d32f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void ALVAR_EXPORT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealvar.html#a0f0a4f61687b86ab95b80e70e0ba6b6b">BuildHideTexture</a> (IplImage *image, IplImage *hide_texture, <a class="el" href="classalvar_1_1_camera.html">Camera</a> *cam, double gl_modelview[16], <a class="el" href="namespacealvar.html#aea7817f5f6f2ed4f212dbd12e78632a7">PointDouble</a> topleft, <a class="el" href="namespacealvar.html#aea7817f5f6f2ed4f212dbd12e78632a7">PointDouble</a> botright)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function is used to construct a texture image which is needed to hide a marker from the original video frame. See <em>SampleMarkerHide.cpp</em> for example implementation.  <a href="#a0f0a4f61687b86ab95b80e70e0ba6b6b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void ALVAR_EXPORT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealvar.html#a5ac4127ca24f94f8636f443b67dc75fd">DrawTexture</a> (IplImage *image, IplImage *texture, <a class="el" href="classalvar_1_1_camera.html">Camera</a> *cam, double gl_modelview[16], <a class="el" href="namespacealvar.html#aea7817f5f6f2ed4f212dbd12e78632a7">PointDouble</a> topleft, <a class="el" href="namespacealvar.html#aea7817f5f6f2ed4f212dbd12e78632a7">PointDouble</a> botright)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draws the texture generated by <em>BuildHideTexture</em> to given video frame. For better performance, use OpenGL instead. See <em>SampleMarkerHide.cpp</em> for example implementation.  <a href="#a5ac4127ca24f94f8636f443b67dc75fd"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="aa91f0cb7ffa2c8683bcb6ed3172ddf2a"></a><!-- doxytag: member="alvar::EraseItemsEC" ref="aa91f0cb7ffa2c8683bcb6ed3172ddf2a" args="(std::map&lt; int, T &gt; &amp;container, F do_erase_test)" -->
template&lt;typename T , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacealvar.html#aa91f0cb7ffa2c8683bcb6ed3172ddf2a">EraseItemsEC</a> (std::map&lt; int, T &gt; &amp;container, F do_erase_test)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erasing items from container using <em><a class="el" href="classalvar_1_1_do_erase_test.html" title="This is default functor for testing which items in the container should be erased...">DoEraseTest</a></em> type functor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9643c7313e0a000ae6f3b6dc5450fbec"></a><!-- doxytag: member="alvar::MarkerIdToContainerId" ref="a9643c7313e0a000ae6f3b6dc5450fbec" args="(int marker_id, int corner_id, int first_id=0, int last_id=65535)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealvar.html#a9643c7313e0a000ae6f3b6dc5450fbec">MarkerIdToContainerId</a> (int marker_id, int corner_id, int first_id=0, int last_id=65535)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the index used in external container map for specified <em>marker_id</em>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int ALVAR_EXPORT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealvar.html#adc88a793c2e30d484db789af582041eb">FitLines</a> (std::vector&lt; <a class="el" href="structalvar_1_1_line.html">Line</a> &gt; &amp;lines, const std::vector&lt; int &gt; &amp;corners, const std::vector&lt; <a class="el" href="namespacealvar.html#a6e33f89141a4ff02e84359a5e73544c9">PointInt</a> &gt; &amp;edge, IplImage *grey=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fit lines to vector of points.  <a href="#adc88a793c2e30d484db789af582041eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacealvar.html#aea7817f5f6f2ed4f212dbd12e78632a7">PointDouble</a> ALVAR_EXPORT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealvar.html#ae6be8fdf3662f62c5ca14446661154d1">Intersection</a> (const <a class="el" href="structalvar_1_1_line.html">Line</a> &amp;l1, const <a class="el" href="structalvar_1_1_line.html">Line</a> &amp;l2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates an intersection point of two lines.  <a href="#ae6be8fdf3662f62c5ca14446661154d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void ALVAR_EXPORT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealvar.html#a7b1eb9cc5141d5d64a93d80d402a4fcc">errorAtLine</a> (int status, int error, const char *filename, unsigned int line, const char *format,...)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Error reporting function inspired by error_at_line() on Linux.  <a href="#a7b1eb9cc5141d5d64a93d80d402a4fcc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1af10c84a0dad1a62394956d059e545e"></a><!-- doxytag: member="alvar::sleep" ref="a1af10c84a0dad1a62394956d059e545e" args="(unsigned long milliseconds)" -->
void ALVAR_EXPORT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealvar.html#a1af10c84a0dad1a62394956d059e545e">sleep</a> (unsigned long milliseconds)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sleep for a specified amount of milliseconds. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a2557baa553a7d6487d64068fc9be874e"></a><!-- doxytag: member="alvar::Sign" ref="a2557baa553a7d6487d64068fc9be874e" args="(const C &amp;v)" -->
template&lt;class C &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">int ALVAR_EXPORT&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacealvar.html#a2557baa553a7d6487d64068fc9be874e">Sign</a> (const C &amp;v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the sign of a number. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a194150ff48c352c961ccd173cc27fec1"></a><!-- doxytag: member="alvar::Rad2Deg" ref="a194150ff48c352c961ccd173cc27fec1" args="(const C &amp;v)" -->
template&lt;class C &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">double ALVAR_EXPORT&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacealvar.html#a194150ff48c352c961ccd173cc27fec1">Rad2Deg</a> (const C &amp;v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an angle from radians to degrees. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="aa8cc607ba435c9f061e46223df0e9101"></a><!-- doxytag: member="alvar::Deg2Rad" ref="aa8cc607ba435c9f061e46223df0e9101" args="(const C &amp;v)" -->
template&lt;class C &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">double ALVAR_EXPORT&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacealvar.html#aa8cc607ba435c9f061e46223df0e9101">Deg2Rad</a> (const C &amp;v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an angle from degrees to radians. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class PointType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">double&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacealvar.html#a5120d41da4659cff5b4ec1044d8fb255">PointSquaredDistance</a> (PointType p1, PointType p2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the squared distance of two points.  <a href="#a5120d41da4659cff5b4ec1044d8fb255"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int ALVAR_EXPORT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealvar.html#ac554373693548d11fee014fef206a03b">dot</a> (CvPoint *A, CvPoint *B, CvPoint *C)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes dot product AB.BC.  <a href="#ac554373693548d11fee014fef206a03b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int ALVAR_EXPORT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealvar.html#ae6ec4ccacc9bd71827cf5acd5892eca0">cross</a> (CvPoint *A, CvPoint *B, CvPoint *C)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the cross product AB x AC.  <a href="#ae6ec4ccacc9bd71827cf5acd5892eca0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double ALVAR_EXPORT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealvar.html#af5c059175b7378a6e733b367b298523e">distance</a> (CvPoint *A, CvPoint *B)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the distance from A to B.  <a href="#af5c059175b7378a6e733b367b298523e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double ALVAR_EXPORT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealvar.html#ad56e3cc1c0a87e280b4a943830fcfb88">linePointDist</a> (CvPoint *A, CvPoint *B, CvPoint *C, bool isSegment)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the distance from point C to line (segment) AB.  <a href="#ad56e3cc1c0a87e280b4a943830fcfb88"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double ALVAR_EXPORT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealvar.html#a51fa711d7ba68205dd46a50a982a59e8">angle</a> (CvPoint *A, CvPoint *B, CvPoint *C, CvPoint *D, int isDirectionDependent)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the angle between lines AB and CD.  <a href="#a51fa711d7ba68205dd46a50a982a59e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double ALVAR_EXPORT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealvar.html#af8aff4347122fc6a54a4d96bd74c95e2">polyLinePointDist</a> (CvPoint *PointList, int nPnts, CvPoint *C, int *index, int isClosedPolygon)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates minimum distance from <a class="el" href="structalvar_1_1_point.html" title="Simple Point class meant to be inherited from OpenCV point-classes. For example:...">Point</a> C to Polygon whose points are in list PointList.  <a href="#af8aff4347122fc6a54a4d96bd74c95e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void ALVAR_EXPORT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealvar.html#a2ed4ee2c11a14324094117384dd79e6d">FitCVEllipse</a> (const std::vector&lt; <a class="el" href="namespacealvar.html#aea7817f5f6f2ed4f212dbd12e78632a7">PointDouble</a> &gt; &amp;points, CvBox2D &amp;ellipse_box)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Uses OpenCV routine to fit ellipse to a vector of points.  <a href="#a2ed4ee2c11a14324094117384dd79e6d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a65945dc8a9438903ea1b7c9f24a9cec8"></a><!-- doxytag: member="alvar::exp_filt2" ref="a65945dc8a9438903ea1b7c9f24a9cec8" args="(std::vector&lt; double &gt; &amp;v, std::vector&lt; double &gt; &amp;ret, bool clamp)" -->
int ALVAR_EXPORT&nbsp;</td><td class="memItemRight" valign="bottom"><b>exp_filt2</b> (std::vector&lt; double &gt; &amp;v, std::vector&lt; double &gt; &amp;ret, bool clamp)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">int ALVAR_EXPORT&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacealvar.html#a9aa0767998ed7db789455e08076b0b65">diff</a> (const std::vector&lt; C &gt; &amp;v, std::vector&lt; C &gt; &amp;ret)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates the difference between the consecutive vector elements.  <a href="#a9aa0767998ed7db789455e08076b0b65"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int ALVAR_EXPORT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealvar.html#a197d1203988f1c6349f587447f8cf623">find_zero_crossings</a> (const std::vector&lt; double &gt; &amp;v, std::vector&lt; int &gt; &amp;corners, int offs=20)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finds zero crossings of given vector elements (sequence).  <a href="#a197d1203988f1c6349f587447f8cf623"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a303b205e54a86b2ae51051e07df940c3"></a><!-- doxytag: member="alvar::out_matrix" ref="a303b205e54a86b2ae51051e07df940c3" args="(const CvMat *m, const char *name)" -->
void ALVAR_EXPORT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealvar.html#a303b205e54a86b2ae51051e07df940c3">out_matrix</a> (const CvMat *m, const char *name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output OpenCV matrix for debug purposes. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double ALVAR_EXPORT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealvar.html#a3b6789058826eef4625e281551dcf1dd">Limit</a> (double val, double min_val, double max_val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Limits a number to between two values.  <a href="#a3b6789058826eef4625e281551dcf1dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf452ad98b6acaf29cfdacbfcb77f63b"></a><!-- doxytag: member="alvar::STRCPY" ref="aaf452ad98b6acaf29cfdacbfcb77f63b" args="(char *to, size_t size, const char *src)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>STRCPY</b> (char *to, size_t size, const char *src)</td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adbf20a674a6c04675c5031fcf94d4c0c"></a><!-- doxytag: member="alvar::ALVAR_VERSION_MAJOR" ref="adbf20a674a6c04675c5031fcf94d4c0c" args="" -->
static const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealvar.html#adbf20a674a6c04675c5031fcf94d4c0c">ALVAR_VERSION_MAJOR</a> = 2</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Major version number. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33289186e3306602e597621ecbcc99e0"></a><!-- doxytag: member="alvar::ALVAR_VERSION_MINOR" ref="a33289186e3306602e597621ecbcc99e0" args="" -->
static const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealvar.html#a33289186e3306602e597621ecbcc99e0">ALVAR_VERSION_MINOR</a> = 0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Minor version number. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed07356b25516f929657419e8861f0f8"></a><!-- doxytag: member="alvar::ALVAR_VERSION_PATCH" ref="aed07356b25516f929657419e8861f0f8" args="" -->
static const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealvar.html#aed07356b25516f929657419e8861f0f8">ALVAR_VERSION_PATCH</a> = 0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Patch version number. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealvar.html#a2775f535469e896e71d14847ed881ca4">ALVAR_VERSION_TAG</a> = &quot;&quot;</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tag version string.  <a href="#a2775f535469e896e71d14847ed881ca4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealvar.html#a8ac976b099c1221c4c6e979d4ba5758e">ALVAR_VERSION_REVISION</a> = &quot;&quot;</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Revision version string.  <a href="#a8ac976b099c1221c4c6e979d4ba5758e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a264241e058e956b622bb93dfb33d1be7"></a><!-- doxytag: member="alvar::ALVAR_VERSION" ref="a264241e058e956b622bb93dfb33d1be7" args="" -->
static const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealvar.html#a264241e058e956b622bb93dfb33d1be7">ALVAR_VERSION</a> = &quot;2.0.0&quot;</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Entire version string. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a40fa3fe404ee33347486f0932c49af22"></a><!-- doxytag: member="alvar::ALVAR_VERSION_NODOTS" ref="a40fa3fe404ee33347486f0932c49af22" args="" -->
static const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealvar.html#a40fa3fe404ee33347486f0932c49af22">ALVAR_VERSION_NODOTS</a> = &quot;200&quot;</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Entire version string without dots. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04fcf9cab3e4d63bf9cc678f7ff69967"></a><!-- doxytag: member="alvar::ALVAR_DATE" ref="a04fcf9cab3e4d63bf9cc678f7ff69967" args="" -->
static const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealvar.html#a04fcf9cab3e4d63bf9cc678f7ff69967">ALVAR_DATE</a> = &quot;2012-05-29&quot;</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Date the library was built. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace7610eb3a84e383d882f691ad98455a"></a><!-- doxytag: member="alvar::ALVAR_SYSTEM" ref="ace7610eb3a84e383d882f691ad98455a" args="" -->
static const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealvar.html#ace7610eb3a84e383d882f691ad98455a">ALVAR_SYSTEM</a> = &quot;Linux 2.6.32-41-generic x86_64&quot;</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">System the library was built on. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a952eac791b596a61bba0a133a3bb439f"></a><!-- doxytag: member="alvar::PI" ref="a952eac791b596a61bba0a133a3bb439f" args="" -->
const double&nbsp;</td><td class="memItemRight" valign="bottom"><b>PI</b> = 3.14159265</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Main ALVAR namespace. </p>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a89021fa008d0a93e735361ed4f3b885f"></a><!-- doxytag: member="alvar::FILE_FORMAT" ref="a89021fa008d0a93e735361ed4f3b885f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacealvar.html#a89021fa008d0a93e735361ed4f3b885f">FILE_FORMAT</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>File format enumeration used when reading / writing configuration files. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a89021fa008d0a93e735361ed4f3b885fabc1b8eac28182f50a5dadf8bd06f7cf2"></a><!-- doxytag: member="FILE_FORMAT_DEFAULT" ref="a89021fa008d0a93e735361ed4f3b885fabc1b8eac28182f50a5dadf8bd06f7cf2" args="" -->FILE_FORMAT_DEFAULT</em>&nbsp;</td><td>
<p>Default file format. </p>
<p>Format is either OPENCV, TEXT or XML depending on load/store function used. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a89021fa008d0a93e735361ed4f3b885fa7b691a0a33e305edaa80da4d7626102a"></a><!-- doxytag: member="FILE_FORMAT_OPENCV" ref="a89021fa008d0a93e735361ed4f3b885fa7b691a0a33e305edaa80da4d7626102a" args="" -->FILE_FORMAT_OPENCV</em>&nbsp;</td><td>
<p>File format written with cvWrite. </p>
<p>File contents depend on the specific load/store function used. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a89021fa008d0a93e735361ed4f3b885fab45b29c2d23300541c899f7ae91b393f"></a><!-- doxytag: member="FILE_FORMAT_TEXT" ref="a89021fa008d0a93e735361ed4f3b885fab45b29c2d23300541c899f7ae91b393f" args="" -->FILE_FORMAT_TEXT</em>&nbsp;</td><td>
<p>Plain ASCII text file format. </p>
<p>File contents depend on the specific load/store function used. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a89021fa008d0a93e735361ed4f3b885fa564f979051988b03ce9a266ee69bbe04"></a><!-- doxytag: member="FILE_FORMAT_XML" ref="a89021fa008d0a93e735361ed4f3b885fa564f979051988b03ce9a266ee69bbe04" args="" -->FILE_FORMAT_XML</em>&nbsp;</td><td>
<p>XML file format. </p>
<p>XML schema depends on the specific load/store function used. </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="_file_format_8h_source.html#l00039">39</a> of file <a class="el" href="_file_format_8h_source.html">FileFormat.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a51fa711d7ba68205dd46a50a982a59e8"></a><!-- doxytag: member="alvar::angle" ref="a51fa711d7ba68205dd46a50a982a59e8" args="(CvPoint *A, CvPoint *B, CvPoint *C, CvPoint *D, int isDirectionDependent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ALVAR_EXPORT alvar::angle </td>
          <td>(</td>
          <td class="paramtype">CvPoint *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CvPoint *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CvPoint *&nbsp;</td>
          <td class="paramname"> <em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CvPoint *&nbsp;</td>
          <td class="paramname"> <em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>isDirectionDependent</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the angle between lines AB and CD. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>isDirectionDependent</em>&nbsp;</td><td>If isDirectionDependent = 1, angle depends on the order of the points. Otherwise returns smaller angle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>start point of first line </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>B</em>&nbsp;</td><td>end point of first line </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>C</em>&nbsp;</td><td>start point of second line </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>D</em>&nbsp;</td><td>end point of second line </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0f0a4f61687b86ab95b80e70e0ba6b6b"></a><!-- doxytag: member="alvar::BuildHideTexture" ref="a0f0a4f61687b86ab95b80e70e0ba6b6b" args="(IplImage *image, IplImage *hide_texture, Camera *cam, double gl_modelview[16], PointDouble topleft, PointDouble botright)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ALVAR_EXPORT alvar::BuildHideTexture </td>
          <td>(</td>
          <td class="paramtype">IplImage *&nbsp;</td>
          <td class="paramname"> <em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IplImage *&nbsp;</td>
          <td class="paramname"> <em>hide_texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Camera *&nbsp;</td>
          <td class="paramname"> <em>cam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>gl_modelview</em>[16], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointDouble&nbsp;</td>
          <td class="paramname"> <em>topleft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointDouble&nbsp;</td>
          <td class="paramname"> <em>botright</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function is used to construct a texture image which is needed to hide a marker from the original video frame. See <em>SampleMarkerHide.cpp</em> for example implementation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>image</em>&nbsp;</td><td>Pointer to the original video frame from where the hiding texture is calculated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hide_texture</em>&nbsp;</td><td>Pointer to the destination image where the resulting texture is stored. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cam</em>&nbsp;</td><td><a class="el" href="classalvar_1_1_camera.html" title="Simple Camera class for calculating distortions, orientation or projections with...">Camera</a> object that is used for marker tracking. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gl_modelview</em>&nbsp;</td><td>Current model view matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>topleft</em>&nbsp;</td><td>Top left limit of the texture area in marker coordinate frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>botright</em>&nbsp;</td><td>Bottom right limit of the texture area in marker coordinate frame. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="_sample_marker_hide_8cpp-example.html#a8">SampleMarkerHide.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ae6ec4ccacc9bd71827cf5acd5892eca0"></a><!-- doxytag: member="alvar::cross" ref="ae6ec4ccacc9bd71827cf5acd5892eca0" args="(CvPoint *A, CvPoint *B, CvPoint *C)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ALVAR_EXPORT alvar::cross </td>
          <td>(</td>
          <td class="paramtype">CvPoint *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CvPoint *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CvPoint *&nbsp;</td>
          <td class="paramname"> <em>C</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the cross product AB x AC. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>A,B</em>&nbsp;</td><td>and C points defining lines (line segments) AB and AC </td></tr>
    <tr><td valign="top"></td><td valign="top"><em></em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9aa0767998ed7db789455e08076b0b65"></a><!-- doxytag: member="alvar::diff" ref="a9aa0767998ed7db789455e08076b0b65" args="(const std::vector&lt; C &gt; &amp;v, std::vector&lt; C &gt; &amp;ret)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ALVAR_EXPORT alvar::diff </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; C &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; C &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>ret</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates the difference between the consecutive vector elements. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>Source elements. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ret</em>&nbsp;</td><td>The difference vector. This is cleared and then resized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of elements. </dd></dl>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00191">191</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a class="anchor" id="af5c059175b7378a6e733b367b298523e"></a><!-- doxytag: member="alvar::distance" ref="af5c059175b7378a6e733b367b298523e" args="(CvPoint *A, CvPoint *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ALVAR_EXPORT alvar::distance </td>
          <td>(</td>
          <td class="paramtype">CvPoint *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CvPoint *&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the distance from A to B. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>and B points </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac554373693548d11fee014fef206a03b"></a><!-- doxytag: member="alvar::dot" ref="ac554373693548d11fee014fef206a03b" args="(CvPoint *A, CvPoint *B, CvPoint *C)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ALVAR_EXPORT alvar::dot </td>
          <td>(</td>
          <td class="paramtype">CvPoint *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CvPoint *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CvPoint *&nbsp;</td>
          <td class="paramname"> <em>C</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes dot product AB.BC. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>A,B</em>&nbsp;</td><td>and C points defining lines (line segments) AB and BC </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3fc556ad55fc084e9de1ee6668d75c18"></a><!-- doxytag: member="alvar::DrawBB" ref="a3fc556ad55fc084e9de1ee6668d75c18" args="(IplImage *image, const std::vector&lt; PointType &gt; &amp;points, CvScalar color, std::string label=&quot;&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void alvar::DrawBB </td>
          <td>(</td>
          <td class="paramtype">IplImage *&nbsp;</td>
          <td class="paramname"> <em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; PointType &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CvScalar&nbsp;</td>
          <td class="paramname"> <em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>label</em> = <code>&quot;&quot;</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws the bounding box of a connected component (Blob). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>image</em>&nbsp;</td><td>Pointer to the destination image. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>points</em>&nbsp;</td><td>Vector of points that determine the bounding box. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>color</em>&nbsp;</td><td>Use CV_RGB(red,green,blue) to determine the color of the bounding box. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>label</em>&nbsp;</td><td>A label to show in the center of the bounding box. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_draw_8h_source.html#l00049">49</a> of file <a class="el" href="_draw_8h_source.html">Draw.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab3bba4775c2aee2e903df3315a2b7aa2"></a><!-- doxytag: member="alvar::DrawCircles" ref="ab3bba4775c2aee2e903df3315a2b7aa2" args="(IplImage *image, const CvSeq *contour, int radius, CvScalar color=CV_RGB(255, 0, 0))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ALVAR_EXPORT alvar::DrawCircles </td>
          <td>(</td>
          <td class="paramtype">IplImage *&nbsp;</td>
          <td class="paramname"> <em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CvSeq *&nbsp;</td>
          <td class="paramname"> <em>contour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CvScalar&nbsp;</td>
          <td class="paramname"> <em>color</em> = <code>CV_RGB(255,&nbsp;0,&nbsp;0)</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws circles to the contour points that are obtained by <em><a class="el" href="classalvar_1_1_labeling.html" title="Base class for labeling connected components from binary image.">Labeling</a></em> class. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>image</em>&nbsp;</td><td>Pointer to the destination image. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>contour</em>&nbsp;</td><td>Controur sequence. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>radius</em>&nbsp;</td><td>Circle radius in pixels. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>color</em>&nbsp;</td><td>Use CV_RGB(red,green,blue) to determine the color. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0bdb9a2950fb73bcb5336594ba47d32f"></a><!-- doxytag: member="alvar::DrawCVEllipse" ref="a0bdb9a2950fb73bcb5336594ba47d32f" args="(IplImage *image, CvBox2D &amp;ellipse, CvScalar color, bool fill=false, double par=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ALVAR_EXPORT alvar::DrawCVEllipse </td>
          <td>(</td>
          <td class="paramtype">IplImage *&nbsp;</td>
          <td class="paramname"> <em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CvBox2D &amp;&nbsp;</td>
          <td class="paramname"> <em>ellipse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CvScalar&nbsp;</td>
          <td class="paramname"> <em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>fill</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>par</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws OpenCV ellipse. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>image</em>&nbsp;</td><td>Pointer to the destination image. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ellipse</em>&nbsp;</td><td>Ellipse struct in OpenCV format. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>color</em>&nbsp;</td><td>Use CV_RGB(red,green,blue) to determine the color. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fill</em>&nbsp;</td><td>If false, only the outline is drawn. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>par</em>&nbsp;</td><td>The ellipse width and height are grown by <em>par</em> pixels. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3765e40337ee76458a5978e34fa08742"></a><!-- doxytag: member="alvar::DrawLine" ref="a3765e40337ee76458a5978e34fa08742" args="(IplImage *image, const Line line, CvScalar color=CV_RGB(0, 255, 0))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ALVAR_EXPORT alvar::DrawLine </td>
          <td>(</td>
          <td class="paramtype">IplImage *&nbsp;</td>
          <td class="paramname"> <em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Line&nbsp;</td>
          <td class="paramname"> <em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CvScalar&nbsp;</td>
          <td class="paramname"> <em>color</em> = <code>CV_RGB(0,&nbsp;255,&nbsp;0)</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws a line. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>image</em>&nbsp;</td><td>Pointer to the destination image. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>line</em>&nbsp;</td><td><a class="el" href="structalvar_1_1_line.html" title="Struct representing a line. The line is parametrized by its center and direction...">Line</a> struct to be drawn. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>color</em>&nbsp;</td><td>Use CV_RGB(red,green,blue) to determine the color. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a21176cd4aef32ec8a32e35c9d5643e08"></a><!-- doxytag: member="alvar::DrawLines" ref="a21176cd4aef32ec8a32e35c9d5643e08" args="(IplImage *image, const CvSeq *contour, CvScalar color=CV_RGB(255, 0, 0))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ALVAR_EXPORT alvar::DrawLines </td>
          <td>(</td>
          <td class="paramtype">IplImage *&nbsp;</td>
          <td class="paramname"> <em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CvSeq *&nbsp;</td>
          <td class="paramname"> <em>contour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CvScalar&nbsp;</td>
          <td class="paramname"> <em>color</em> = <code>CV_RGB(255,&nbsp;0,&nbsp;0)</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws lines between consecutive contour points. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>image</em>&nbsp;</td><td>Pointer to the destination image. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>contour</em>&nbsp;</td><td>Controur sequence. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>color</em>&nbsp;</td><td>Use CV_RGB(red,green,blue) to determine the color. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a364de71f15f15353b2a1ac8a44d58b12"></a><!-- doxytag: member="alvar::DrawLines" ref="a364de71f15f15353b2a1ac8a44d58b12" args="(IplImage *image, const std::vector&lt; PointType &gt; &amp;points, CvScalar color, bool loop=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void alvar::DrawLines </td>
          <td>(</td>
          <td class="paramtype">IplImage *&nbsp;</td>
          <td class="paramname"> <em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; PointType &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CvScalar&nbsp;</td>
          <td class="paramname"> <em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>loop</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws lines between consecutive points stored in vector (polyline). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>image</em>&nbsp;</td><td>Pointer to the destination image. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>points</em>&nbsp;</td><td>Vector of points that determine the polyline. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>color</em>&nbsp;</td><td>Use CV_RGB(red,green,blue) to determine the color. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>loop</em>&nbsp;</td><td>If true, the polyline is closed. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_draw_8h_source.html#l00088">88</a> of file <a class="el" href="_draw_8h_source.html">Draw.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3a4da86635d9fe87a82c6d587fcb9d0f"></a><!-- doxytag: member="alvar::DrawPoints" ref="a3a4da86635d9fe87a82c6d587fcb9d0f" args="(IplImage *image, const std::vector&lt; PointType &gt; &amp;points, CvScalar color, int radius=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void alvar::DrawPoints </td>
          <td>(</td>
          <td class="paramtype">IplImage *&nbsp;</td>
          <td class="paramname"> <em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; PointType &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CvScalar&nbsp;</td>
          <td class="paramname"> <em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>radius</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws circles to the array of points. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>image</em>&nbsp;</td><td>Pointer to the destination image. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>points</em>&nbsp;</td><td>Vector of points to be visualized. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>color</em>&nbsp;</td><td>Use CV_RGB(red,green,blue) to determine the color. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>radius</em>&nbsp;</td><td>Circle radius in pixels. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_draw_8h_source.html#l00134">134</a> of file <a class="el" href="_draw_8h_source.html">Draw.h</a>.</p>

</div>
</div>
<a class="anchor" id="a077b3694a57b120485fe577d01602620"></a><!-- doxytag: member="alvar::DrawPoints" ref="a077b3694a57b120485fe577d01602620" args="(IplImage *image, const CvSeq *contour, CvScalar color=CV_RGB(255, 0, 0))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ALVAR_EXPORT alvar::DrawPoints </td>
          <td>(</td>
          <td class="paramtype">IplImage *&nbsp;</td>
          <td class="paramname"> <em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CvSeq *&nbsp;</td>
          <td class="paramname"> <em>contour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CvScalar&nbsp;</td>
          <td class="paramname"> <em>color</em> = <code>CV_RGB(255,&nbsp;0,&nbsp;0)</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws points of the contour that is obtained by <em><a class="el" href="classalvar_1_1_labeling.html" title="Base class for labeling connected components from binary image.">Labeling</a></em> class. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>image</em>&nbsp;</td><td>Pointer to the destination image. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>contour</em>&nbsp;</td><td>Controur sequence. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>color</em>&nbsp;</td><td>Use CV_RGB(red,green,blue) to determine the color. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aba302fe494ca21b2f29bcd93cbe6bc2c"></a><!-- doxytag: member="alvar::DrawPoints" ref="aba302fe494ca21b2f29bcd93cbe6bc2c" args="(IplImage *image, const std::vector&lt; CvPoint &gt; &amp;points, CvScalar color)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ALVAR_EXPORT alvar::DrawPoints </td>
          <td>(</td>
          <td class="paramtype">IplImage *&nbsp;</td>
          <td class="paramname"> <em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; CvPoint &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CvScalar&nbsp;</td>
          <td class="paramname"> <em>color</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws a set of points. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>image</em>&nbsp;</td><td>Pointer to the destination image. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>points</em>&nbsp;</td><td>Array of CvPoints to be visualzed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>color</em>&nbsp;</td><td>Use CV_RGB(red,green,blue) to determine the color. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5ac4127ca24f94f8636f443b67dc75fd"></a><!-- doxytag: member="alvar::DrawTexture" ref="a5ac4127ca24f94f8636f443b67dc75fd" args="(IplImage *image, IplImage *texture, Camera *cam, double gl_modelview[16], PointDouble topleft, PointDouble botright)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ALVAR_EXPORT alvar::DrawTexture </td>
          <td>(</td>
          <td class="paramtype">IplImage *&nbsp;</td>
          <td class="paramname"> <em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IplImage *&nbsp;</td>
          <td class="paramname"> <em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Camera *&nbsp;</td>
          <td class="paramname"> <em>cam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>gl_modelview</em>[16], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointDouble&nbsp;</td>
          <td class="paramname"> <em>topleft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointDouble&nbsp;</td>
          <td class="paramname"> <em>botright</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws the texture generated by <em>BuildHideTexture</em> to given video frame. For better performance, use OpenGL instead. See <em>SampleMarkerHide.cpp</em> for example implementation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>image</em>&nbsp;</td><td>Pointer to the destination image where the texture is drawn. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>texure</em>&nbsp;</td><td>Pointer to the texture image genereated by <em>BuildHideTexture</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cam</em>&nbsp;</td><td><a class="el" href="classalvar_1_1_camera.html" title="Simple Camera class for calculating distortions, orientation or projections with...">Camera</a> object that is used for marker tracking. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gl_modelview</em>&nbsp;</td><td>Current model view matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>topleft</em>&nbsp;</td><td>Top left limit of the texture area in marker coordinate frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>botright</em>&nbsp;</td><td>Bottom right limit of the texture area in marker coordinate frame. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7b1eb9cc5141d5d64a93d80d402a4fcc"></a><!-- doxytag: member="alvar::errorAtLine" ref="a7b1eb9cc5141d5d64a93d80d402a4fcc" args="(int status, int error, const char *filename, unsigned int line, const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ALVAR_EXPORT alvar::errorAtLine </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Error reporting function inspired by error_at_line() on Linux. </p>
<p>It flushes stdout and prints the filename, line number and printf compatible error message to stderr. If error is specified, it also prints the corresponding error message from strerror(). If status is not zero, it exits the process. </p>

</div>
</div>
<a class="anchor" id="a197d1203988f1c6349f587447f8cf623"></a><!-- doxytag: member="alvar::find_zero_crossings" ref="a197d1203988f1c6349f587447f8cf623" args="(const std::vector&lt; double &gt; &amp;v, std::vector&lt; int &gt; &amp;corners, int offs=20)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ALVAR_EXPORT alvar::find_zero_crossings </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>corners</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>offs</em> = <code>20</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finds zero crossings of given vector elements (sequence). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>Sequence of numbers from where the zero crossings are found. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>corners</em>&nbsp;</td><td>Resulting index list of zero crossings. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offs</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of zero crossings found. </dd></dl>

</div>
</div>
<a class="anchor" id="a2ed4ee2c11a14324094117384dd79e6d"></a><!-- doxytag: member="alvar::FitCVEllipse" ref="a2ed4ee2c11a14324094117384dd79e6d" args="(const std::vector&lt; PointDouble &gt; &amp;points, CvBox2D &amp;ellipse_box)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ALVAR_EXPORT alvar::FitCVEllipse </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; PointDouble &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CvBox2D &amp;&nbsp;</td>
          <td class="paramname"> <em>ellipse_box</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Uses OpenCV routine to fit ellipse to a vector of points. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>points</em>&nbsp;</td><td>Vector of points on the ellipse edge. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ellipse_box</em>&nbsp;</td><td>OpenCV struct for the fitted ellipse. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adc88a793c2e30d484db789af582041eb"></a><!-- doxytag: member="alvar::FitLines" ref="adc88a793c2e30d484db789af582041eb" args="(std::vector&lt; Line &gt; &amp;lines, const std::vector&lt; int &gt; &amp;corners, const std::vector&lt; PointInt &gt; &amp;edge, IplImage *grey=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ALVAR_EXPORT alvar::FitLines </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Line &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>corners</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; PointInt &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IplImage *&nbsp;</td>
          <td class="paramname"> <em>grey</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fit lines to vector of points. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lines</em>&nbsp;</td><td>Resulting set of lines. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>corners</em>&nbsp;</td><td><a class="el" href="structalvar_1_1_index.html" title="Class for N-dimensional index to be used e.g. with STL maps.">Index</a> list of line breaks. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>edge</em>&nbsp;</td><td>Vector of points (pixels) where the line is fitted. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>grey</em>&nbsp;</td><td>In the future, we may want to fit lines directly to grayscale image instead of thresholded edge. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae6be8fdf3662f62c5ca14446661154d1"></a><!-- doxytag: member="alvar::Intersection" ref="ae6be8fdf3662f62c5ca14446661154d1" args="(const Line &amp;l1, const Line &amp;l2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacealvar.html#aea7817f5f6f2ed4f212dbd12e78632a7">PointDouble</a> ALVAR_EXPORT alvar::Intersection </td>
          <td>(</td>
          <td class="paramtype">const Line &amp;&nbsp;</td>
          <td class="paramname"> <em>l1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Line &amp;&nbsp;</td>
          <td class="paramname"> <em>l2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates an intersection point of two lines. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>l1</em>&nbsp;</td><td>First line. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l2</em>&nbsp;</td><td>Second line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Intersection point. </dd></dl>

</div>
</div>
<a class="anchor" id="a3b6789058826eef4625e281551dcf1dd"></a><!-- doxytag: member="alvar::Limit" ref="a3b6789058826eef4625e281551dcf1dd" args="(double val, double min_val, double max_val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ALVAR_EXPORT alvar::Limit </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>min_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>max_val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Limits a number to between two values. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>Input value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>min_val</em>&nbsp;</td><td>Minimum value for the result. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max_val</em>&nbsp;</td><td>Maximum value for the result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Resulting value that is between <em>min_val</em> and <em>max_val</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="ad56e3cc1c0a87e280b4a943830fcfb88"></a><!-- doxytag: member="alvar::linePointDist" ref="ad56e3cc1c0a87e280b4a943830fcfb88" args="(CvPoint *A, CvPoint *B, CvPoint *C, bool isSegment)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ALVAR_EXPORT alvar::linePointDist </td>
          <td>(</td>
          <td class="paramtype">CvPoint *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CvPoint *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CvPoint *&nbsp;</td>
          <td class="paramname"> <em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>isSegment</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the distance from point C to line (segment) AB. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>isSegment</em>&nbsp;</td><td>If isSegment is true, AB is a segment, not a line. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>C</em>&nbsp;</td><td>point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>abd B points defining line (segment) AB </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5120d41da4659cff5b4ec1044d8fb255"></a><!-- doxytag: member="alvar::PointSquaredDistance" ref="a5120d41da4659cff5b4ec1044d8fb255" args="(PointType p1, PointType p2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double alvar::PointSquaredDistance </td>
          <td>(</td>
          <td class="paramtype">PointType&nbsp;</td>
          <td class="paramname"> <em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointType&nbsp;</td>
          <td class="paramname"> <em>p2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the squared distance of two points. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p1</em>&nbsp;</td><td>First point. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p2</em>&nbsp;</td><td>Second point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Squared distance. </dd></dl>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00115">115</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a class="anchor" id="af8aff4347122fc6a54a4d96bd74c95e2"></a><!-- doxytag: member="alvar::polyLinePointDist" ref="af8aff4347122fc6a54a4d96bd74c95e2" args="(CvPoint *PointList, int nPnts, CvPoint *C, int *index, int isClosedPolygon)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ALVAR_EXPORT alvar::polyLinePointDist </td>
          <td>(</td>
          <td class="paramtype">CvPoint *&nbsp;</td>
          <td class="paramname"> <em>PointList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nPnts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CvPoint *&nbsp;</td>
          <td class="paramname"> <em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>isClosedPolygon</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates minimum distance from <a class="el" href="structalvar_1_1_point.html" title="Simple Point class meant to be inherited from OpenCV point-classes. For example:...">Point</a> C to Polygon whose points are in list PointList. </p>
<p>Returns distance </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>index of point A in pointlist, where A is the starting point of the closest polygon segment </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>isClosedPolygon</em>&nbsp;</td><td>is true if polygon is closed (segment of the first and last point is also checked) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a8ac976b099c1221c4c6e979d4ba5758e"></a><!-- doxytag: member="alvar::ALVAR_VERSION_REVISION" ref="a8ac976b099c1221c4c6e979d4ba5758e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* <a class="el" href="namespacealvar.html#a8ac976b099c1221c4c6e979d4ba5758e">ALVAR_VERSION_REVISION</a> = &quot;&quot;<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Revision version string. </p>
<p>The revision contains an identifier from the source control system. </p>

<p>Definition at line <a class="el" href="_alvar_8h_source.html#l00203">203</a> of file <a class="el" href="_alvar_8h_source.html">Alvar.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2775f535469e896e71d14847ed881ca4"></a><!-- doxytag: member="alvar::ALVAR_VERSION_TAG" ref="a2775f535469e896e71d14847ed881ca4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* <a class="el" href="namespacealvar.html#a2775f535469e896e71d14847ed881ca4">ALVAR_VERSION_TAG</a> = &quot;&quot;<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tag version string. </p>
<p>The tag contains alpha, beta and release candidate versions. </p>

<p>Definition at line <a class="el" href="_alvar_8h_source.html#l00196">196</a> of file <a class="el" href="_alvar_8h_source.html">Alvar.h</a>.</p>

</div>
</div>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Tue May 29 18:20:30 2012 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
